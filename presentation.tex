\documentclass{beamer}

\usepackage[utf8]{inputenc}
 
\usepackage{listings}
\usepackage{color}
%
%\usepackage{graphicx}
%\graphicspath{ {./} }
%
\usepackage[T1]{fontenc}
\usepackage{libertine}
\usepackage[scaled=0.6]{beramono}
\usepackage[export]{adjustbox}

\lstset{
  basicstyle=\linespread{0.65}\ttfamily\small,
  breakatwhitespace=false,     
  breaklines=true,         
  captionpos=b,          
  keepspaces=true,         
  showspaces=false,        
  showstringspaces=false,
  showtabs=false,          
  tabsize=2,
}

\lstdefinelanguage{logic}{
  morekeywords={
    datatype,
    type,
    fun,
    val,
    predicate,
    where, only,
    if, then, else,
    and, or, not,
    lemma,
    theorem,
    of,
    have,
    assume, case, apply, done, by, proof, qed,
    goal
  },
  mathescape
}

\lstdefinelanguage{normal_lang}{
  morekeywords={
    bind, rslt, fun, app, unt, pair,
    mkChn, sync, fst, snd, lft, rht,
    spawn, case, of, sendEvt, recvEvt
  }
}

\lstdefinelanguage{sugar_lang}{
  morekeywords={
    datatype,
    type,
    fun,
    val,
    predicate,
    only, if, then, else,
    and, or, not,
    lemma,
    theorem,
    of,
    fun,
    bind, rslt, unt, pair,
    chn, lft, rht,
    sendEvt, recvEvt
  }
}

\title{A Mechanized Theory of Communication Analysis in CML}

%\usetheme{lucid}
\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
\frametitle{Concurrent ML}
\begin{itemize}
\item extension of Standard ML
\item concurrency and synchronization
\item synchronized communication over channels: send event, receive event
\item composition of events: choose event, wrap event ...
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Concurrent ML}
\begin{lstlisting}[language=ML]

type thread_id
val spawn : (unit -> unit) -> thread_id

type 'a chan
val channel : unit -> 'a chan

type 'a event
val sync: 'a event -> 'a

val recvEvt: 'a chan -> 'a event
val sendEvt: 'a channel * 'a -> unit event

val send: 'a chan * 'a -> unit
fun send (ch, v) = sync (sendEvt (ch, v))

val recv: 'a chan -> 'a
fun recv ch = sync (recvEvt ch)

\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Concurrent ML}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=ML, mathescape]
structure Serv : SERV =
struct 
  datatype serv = S of (int * int chan) chan

  fun make () =
  let 
    val reqCh = channel ()
    fun loop state =
    let
      val (v, replCh) = recv reqCh
      val () = send (replCh, state)
    in
      loop v
    end
    val () = spawn (fn () => loop 0)
  in
    S reqCh
  end 
\end{lstlisting}
\end{column}


\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=ML, mathescape]
  fun call (server, v) =
  let 
    val S reqCh = server
    val replCh = channel () 
    val () = send (reqCh, (v, replCh))
  in
    recv replCh
  end
end

signature SERV =
sig 
  type serv
  val make : unit -> serv
  val call : serv * int -> int
end
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}



\begin{frame}
\frametitle{Isabelle/HOL}
\begin{itemize}
\item interactive theorem proving assistant; proof assistant
\item unification and rewriting
\item simply typed terms
\item propositions as boolean typed terms
\item higher order terms
\item computable functions
\item inductive data
\item inductive reasoning
\item tactics and composition
\end{itemize}
\end{frame}



\begin{frame}[fragile]
	\frametitle{Isabelle/HOL}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=logic, mathescape]
$\vdash$ P1 $\vee$ P2 $\rightarrow$ Q
proof
  assume P1 $\vee$ P2:
    case P1:
      have $\vdash$ P1 $\rightarrow$ Q by A
      have $\vdash$ Q by modus ponens
    case P2:
      have $\vdash$ P2 $\rightarrow$ Q by B    
      have $\vdash$ Q by modus ponens
    have P1 $\vdash$ Q, P2 $\vdash$ Q
    have $\vdash$ Q by disjunction elimination
  have P1 $\vee$ P2 $\vdash$ Q
  have $\vdash$ P1 $\vee$ P2 $\rightarrow$ Q
    by implication introduction  
qed
\end{lstlisting}
\end{column}

\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=logic, mathescape]
$\vdash$ P1 $\vee$ P2 $\rightarrow$ Q
apply (rule impI)
  P1 $\vee$ P2 $\vdash$ Q
apply (erule disjE)
  P1 $\vdash$ Q
* P2 $\vdash$ Q
apply (insert A)
  P1, P1 $\rightarrow$ Q $\vdash$ Q
* P2 $\vdash$ Q
apply (erule mp)
  P1 $\vdash$ P1
* P2 $\vdash$ Q
apply assumption 
  P2 $\vdash$ Q
apply (insert B)
  P2, P2 $\rightarrow$ Q $\vdash$ Q
apply (erule mp)
  P2 $\vdash$ P2
apply assumption 
done
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}






\begin{frame}[fragile]
	\frametitle{Isabelle/HOL}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=logic, mathescape]
datatype nat = Z | S nat

predicate lte: nat -> nat -> bool where
  eq: n . 
  $\vdash$ lte n n
* lt: n$_1$ n$_2$ . 
    lte n$_1$ n$_2$ 
  $\vdash$ lte n$_1$ (S n$_2$)
\end{lstlisting}
\end{column}

\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=logic, mathescape]
datatype 'a list =
  Nil
| Cons 'a ('a list)
 
predicate sorted:
  ('a -> 'a -> bool) -> 'a list -> bool
where
  nil: r . 
  $\vdash$ sorted r Nil
* uni: r x . 
  $\vdash$ sorted r (Cons x Nil)
* cons: r x y ys .
    r x y,
    sorted r (Cons y ys)
  $\vdash$ sorted r (Cons x (Cons y ys))
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}





\begin{frame}[fragile]
\frametitle{Isabelle/HOL}
\begin{lstlisting}[language=logic, mathescape]
$\vdash$ sorted lte (Cons (Z) (Cons (S Z) (Cons (S Z) (Cons (S (S (S Z))) Nil))))
apply (rule cons)
  $\vdash$ lte Z (S Z)
* $\vdash$ sorted lte (Cons (S Z) (Cons (S Z) (Cons (S (S (S Z))) Nil)))
apply (rule lt)
  $\vdash$ lte Z Z
* $\vdash$ sorted lte (Cons (S Z) (Cons (S Z) (Cons (S (S (S Z))) Nil)))
apply (rule eq)
  $\vdash$ sorted lte (Cons (S Z) (Cons (S Z) (Cons (S (S (S Z))) Nil)))
apply (rule cons)
  $\vdash$ lte (S Z) (S Z)
* $\vdash$ sorted lte (Cons (S Z) (Cons (S (S (S Z))) Nil))
apply (rule eq)
  $\vdash$ sorted lte (Cons (S Z) (Cons (S (S (S Z))) Nil))
apply (rule cons)
  $\vdash$ lte (S Z) (S (S (S Z)))
* $\vdash$ sorted lte (Cons (S (S (S Z))) Nil)
apply (rule lt)
  $\vdash$ lte (S Z) (S (S Z))
* $\vdash$ sorted lte (Cons (S (S (S Z))) Nil)
apply (rule lt)
  $\vdash$ lte (S Z) (S Z)
* $\vdash$ sorted lte (Cons (S (S (S Z))) Nil)
apply (rule eq)
  $\vdash$ sorted lte (Cons (S (S (S Z))) Nil)
apply (rule uni)
done
\end{lstlisting}
\end{frame}



\begin{frame}
\frametitle{Analysis}
\begin{itemize}
\item communication classification: one-shot, one-to-many, many-to-one, many-to-many
\item control flow analysis
\item channel liveness
\item algorithm vs constraints
\item structural recursion vs fixpoint accumulation
\item performance improvements
\item safety
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Synchronization}
\begin{itemize}
\item uniprocessor; dispatch scheduling
\item multiprocessor; mutex and compare-and-swap
\item synchronization state
\item sender and receiver thread containers
\item message containers
\end{itemize}
\end{frame}



\begin{frame}[fragile]
	\frametitle{Syntax}
\begin{lstlisting}[language=logic, mathescape]
datatype name = Nm string

datatype term = 
  Bind name complex term 
| Rslt name

and complex = 
  Unt
| MkChn
| Atom atom
| Spwn term 
| Sync name
| Fst name
| Snd name
| Case name name term name term 
| App name name

and atom = 
  SendEvt name name
| RecvEvt name
| Pair name name
| Lft name
| Rht name
| Fun name name term 
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]
	\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
datatype dynamic_step =
  DSeq name
| DSpwn name
| DCll name
| DRtn name 

type dynamic_path =
  dynamic_step list

datatype chan =
  Chan dynamic_path name 

datatype dynamic_value = 
  VUnt
| VChn chan
| VAtm atom (name -> dynamic_value option)

type environment =
  name -> dynamic_value option
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
predicate seqEval: complex -> environment -> dynamic_value -> bool where

  unit: env . 
  $\vdash$ seqEval Unt env VUnt

* atom: a env .
  $\vdash$ seqEval (Atom a) env (VAtm a env)

* first: env n$_p$ n$_1$ n$_2$ env$_p$ v . 
    env n$_p$ = Some (VAtm (Pair n$_1$ n$_2$) env$_p$),
    env$_p$ n$_1$ = Some v
  $\vdash$ seqEval (Fst n$_p$) env v

* second: env n$_p$ n$_1$ n$_2$ env$_p$ v . 
    env n$_p$ = Some (VAtm (Pair n$_1$ n$_2$) env$_p$), 
    env$_p$ n$_2$ = Some v 
  $\vdash$ seqEval (Snd n$_p$) env v
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
predicate callEval: complex -> env -> term -> env -> bool where

  distincLeft: env n$_s$ n$_c$ env$_s$ v n$_l$ t$_l$ n$_r$ t$_r$ .
    env n$_s$ = Some (VAtm (Lft n$_c$) env$_s$),
    env$_s$ n$_c$ = Some v
  $\vdash$ callEval (Case n$_s$ n$_l$ t$_l$ n$_r$ t$_r$) env t$_l$ (env(n$_l$ -> v))

* distincRight: env n$_s$ n$_c$ env$_s$ v n$_l$ t$_l$ n$_r$ t$_r$ .
    env n$_s$ = Some (VAtm (Rht n$_c$) env$_s$),
    env$_s$ n$_c$ = Some v
  $\vdash$ callEval (Case n$_s$ n$_l$ t$_l$ n$_r$ t$_r$) env t$_r$ (env(n$_r$ -> v))

* application: env n$_f$ n$_f$' n$_p$ t$_b$ env$_f$ n$_a$ v .
    env n$_f$ = Some (VAtm (Fun n$_f$' n$_p$ t$_b$) env$_f$),
    env n$_a$ = Some v
  $\vdash$ callEval
    (App n$_f$ n$_a$) env t$_b$
    (env$_f$(
      n$_f$' -> (VAtm (Fun n$_f$' n$_p$ t$_b$) env$_f$),
      n$_p$ -> v
    ))
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
datatype contin = Ctn name tm env

type stack = contin list

datatype state =
  Stt program env stack 

type pool =
  dynamic_path -> state option

predicate leaf: pool -> dynamic_path -> bool where
  intro: pool path stt .
    pool path = Some stt,
    ($\nexists$ path' stt' .
      pool path' = Some stt',
      strictPrefix path path'
    )
  $\vdash$ leaf pool path

type corresp = dynamic_path * chan * dynamic_path

type communication = corresp set 
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
predicate dynamicEval:
  pool -> communication -> pool -> communication -> bool
where

  return: pool path n env n$_k$ t$_k$ env$_k$ stack' v comm .
    leaf pool path,
    pool path = Some (Stt (Rslt n) env ((Ctn n$_k$ t$_k$ env$_k$) # stack')),
    env n = Some v
  $\vdash$ dynamicEval
    pool comm
    (pool(
      path @ [DRtn n] ->
        (Stt t$_k$ env$_k$(n$_k$ -> v) stack')
    ))
    comm

* seq: pool path n c t' env stack v .
    leaf pool path,
    pool path = Some (Stt (Bind n c t') env stack),
    seqEval c env v
  $\vdash$ dynamicEval
    pool comm
    (pool(
      path @ [DSeq n] -> (Stt t' (env(n -> v)) stack)
    ))
    comm
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
* call: pool path n c t' env stack t$_c$ env$_c$ comm .
    leaf pool path,
    pool path = Some (Stt (Bind n c t') env stack),
    callEval c env t$_c$ env$_c$
  $\vdash$ dynamicEval
    pool comm
    (pool(
      path @ [DCll n] -> (Stt t$_c$ env$_c$ ((Ctn n t' env) # stack))
    )) comm

* makeChan: pool path n t' env stack .
    leaf pool path,
    pool path = Some (Stt (Bind n MkChn t') env stack)
  $\vdash$ dynamicEval pool comm 
    (pool(
      path @ [DSeq n] ->
        (Stt t' (env(n -> (VChn (Chan path n)))) stack)
    )) comm

* spawn: pool path n t$_c$ t' env stack comm .
    leaf pool path, 
    pool path = Some (Stt (Bind n (Spwn t$_c$) t') env stack)
  $\vdash$ dynamicEval pool comm 
    (pool(
      path @ [DSeq n] -> (Stt t' (env(n -> VUnt)) stack),
      path @ [DSpwn n] -> (Stt t$_c$ env [])
    )) comm
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
* sync: pool path$_s$ n$_s$ n$_{se}$ t$_s$ env$_s$ stack$_s$ n$_{sc}$ n$_m$
  env$_{se}$ path$_r$ n$_r$ n$_{re}$ t$_r$ env$_r$ stack$_r$ n$_{rc}$ env$_{re}$ chan comm .
    leaf pool path$_s$,
    pool path$_s$ = Some
      (Stt (Bind n$_s$ (Sync n$_{se}$) t$_s$) env$_s$ stack$_s$),
    env$_s$ n$_{se}$ = Some
      (VAtm (SendEvt n$_{sc}$ n$_m$) env$_{se}$),
    leaf pool path$_r$,
    pool path$_r$ = Some
      (Stt (Bind n$_r$ (Sync n$_{re}$) t$_r$) env$_r$ stack$_r$),
    env$_r$ n$_{re}$ = Some
      (VAtm (RecvEvt n$_{rc}$) env$_{re}$),
    env$_{se}$ n$_{sc}$ = Some (VChn chan),
    env$_{re}$ n$_{rc}$ = Some (VChn chan), 
    env$_{se}$ n$_m$ = Some v$_m$
  $\vdash$ dynamicEval
    pool comm
    (pool(
      path$_s$ @ [DSeq n$_s$] -> (Stt t$_s$ (env$_s$(n$_s$ -> VUnt)) stack$_s$), 
      path$_r$ @ [DSeq n$_r$] -> (Stt t$_r$ (env$_r$(n$_r$ -> v$_m$)) stack$_r$)
    )) 
    (comm $\cup$ {(path$_s$, chan, path$_r$)})
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Communication}
\begin{lstlisting}[language=logic, mathescape]
  
\end{lstlisting}
\end{frame}



\end{document}
