\documentclass{beamer}

\usepackage[utf8]{inputenc}
 
\usepackage{listings}
\usepackage{color}
%
%\usepackage{graphicx}
%\graphicspath{ {./} }
%
\usepackage[T1]{fontenc}
\usepackage{libertine}
\usepackage[scaled=0.6]{beramono}
\usepackage[export]{adjustbox}

\lstset{
  basicstyle=\linespread{0.65}\ttfamily\small,
  breakatwhitespace=false,     
  breaklines=true,         
  captionpos=b,          
  keepspaces=true,         
  showspaces=false,        
  showstringspaces=false,
  showtabs=false,          
  tabsize=2,
}

\lstdefinelanguage{logic}{
  morekeywords={
    datatype,
    type,
    fun,
    val,
    predicate,
    where, only,
    if, then, else,
    and, or, not,
    lemma,
    theorem,
    of,
    have,
    assume, case, apply, done, by, proof, qed,
    goal
  },
  mathescape
}

\lstdefinelanguage{normal_lang}{
  morekeywords={
    bind, rslt, fun, app, unt, pair,
    mkChn, sync, fst, snd, lft, rht,
    spawn, case, of, sendEvt, recvEvt
  }
}

\lstdefinelanguage{sugar_lang}{
  morekeywords={
    datatype,
    type,
    fun,
    val,
    predicate,
    only, if, then, else,
    and, or, not,
    lemma,
    theorem,
    of,
    fun,
    bind, rslt, unt, pair,
    chn, lft, rht,
    sendEvt, recvEvt
  }
}

\title{A Mechanized Theory of Communication Analysis in CML}

%\usetheme{lucid}
\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
\frametitle{Concurrent ML}
\begin{itemize}
\item extension of Standard ML
\item concurrency and synchronization
\item synchronized communication over channels: send event, receive event
\item composition of events: choose event, wrap event ...
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Concurrent ML}
\begin{lstlisting}[language=ML]

type thread_id
val spawn : (unit -> unit) -> thread_id

type 'a chan
val channel : unit -> 'a chan

type 'a event
val sync: 'a event -> 'a

val recvEvt: 'a chan -> 'a event
val sendEvt: 'a channel * 'a -> unit event

val send: 'a chan * 'a -> unit
fun send (ch, v) = sync (sendEvt (ch, v))

val recv: 'a chan -> 'a
fun recv ch = sync (recvEvt ch)

\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Concurrent ML}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=ML, mathescape]
structure Serv : SERV =
struct 
  datatype serv = S of (int * int chan) chan

  fun make () =
  let 
    val reqCh = channel ()
    fun loop state =
    let
      val (v, replCh) = recv reqCh
      val () = send (replCh, state)
    in
      loop v
    end
    val () = spawn (fn () => loop 0)
  in
    S reqCh
  end 
\end{lstlisting}
\end{column}


\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=ML, mathescape]
  fun call (server, v) =
  let 
    val S reqCh = server
    val replCh = channel () 
    val () = send (reqCh, (v, replCh))
  in
    recv replCh
  end
end

signature SERV =
sig 
  type serv
  val make : unit -> serv
  val call : serv * int -> int
end
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}



\begin{frame}
\frametitle{Isabelle/HOL}
\begin{itemize}
\item interactive theorem proving assistant; proof assistant
\item unification and rewriting
\item simply typed terms
\item propositions as boolean typed terms
\item higher order terms
\item computable functions
\item inductive data
\item inductive reasoning
\item tactics and composition
\end{itemize}
\end{frame}



\begin{frame}[fragile]
	\frametitle{Isabelle/HOL}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=logic, mathescape]
$\vdash$ P1 $\vee$ P2 $\rightarrow$ Q
proof
  assume P1 $\vee$ P2:
    case P1:
      have $\vdash$ P1 $\rightarrow$ Q by A
      have $\vdash$ Q by modus ponens
    case P2:
      have $\vdash$ P2 $\rightarrow$ Q by B    
      have $\vdash$ Q by modus ponens
    have P1 $\vdash$ Q, P2 $\vdash$ Q
    have $\vdash$ Q by disjunction elimination
  have P1 $\vee$ P2 $\vdash$ Q
  have $\vdash$ P1 $\vee$ P2 $\rightarrow$ Q
    by implication introduction  
qed
\end{lstlisting}
\end{column}

\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=logic, mathescape]
$\vdash$ P1 $\vee$ P2 $\rightarrow$ Q
apply (rule impI)
  P1 $\vee$ P2 $\vdash$ Q
apply (erule disjE)
  P1 $\vdash$ Q
* P2 $\vdash$ Q
apply (insert A)
  P1, P1 $\rightarrow$ Q $\vdash$ Q
* P2 $\vdash$ Q
apply (erule mp)
  P1 $\vdash$ P1
* P2 $\vdash$ Q
apply assumption 
  P2 $\vdash$ Q
apply (insert B)
  P2, P2 $\rightarrow$ Q $\vdash$ Q
apply (erule mp)
  P2 $\vdash$ P2
apply assumption 
done
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}






\begin{frame}[fragile]
	\frametitle{Isabelle/HOL}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=logic, mathescape]
datatype nat = Z | S nat

predicate lte: nat -> nat -> bool where
  eq: n . 
  $\vdash$ lte n n
* lt: n$_1$ n$_2$ . 
    lte n$_1$ n$_2$ 
  $\vdash$ lte n$_1$ (S n$_2$)
\end{lstlisting}
\end{column}

\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=logic, mathescape]
datatype 'a list =
  Nil
| Cons 'a ('a list)
 
predicate sorted:
  ('a -> 'a -> bool) -> 'a list -> bool
where
  nil: r . 
  $\vdash$ sorted r Nil
* uni: r x . 
  $\vdash$ sorted r (Cons x Nil)
* cons: r x y ys .
    r x y,
    sorted r (Cons y ys)
  $\vdash$ sorted r (Cons x (Cons y ys))
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}





\begin{frame}[fragile]
\frametitle{Isabelle/HOL}
\begin{lstlisting}[language=logic, mathescape]
$\vdash$ sorted lte (Cons (Z) (Cons (S Z) (Cons (S Z) (Cons (S (S (S Z))) Nil))))
apply (rule cons)
  $\vdash$ lte Z (S Z)
* $\vdash$ sorted lte (Cons (S Z) (Cons (S Z) (Cons (S (S (S Z))) Nil)))
apply (rule lt)
  $\vdash$ lte Z Z
* $\vdash$ sorted lte (Cons (S Z) (Cons (S Z) (Cons (S (S (S Z))) Nil)))
apply (rule eq)
  $\vdash$ sorted lte (Cons (S Z) (Cons (S Z) (Cons (S (S (S Z))) Nil)))
apply (rule cons)
  $\vdash$ lte (S Z) (S Z)
* $\vdash$ sorted lte (Cons (S Z) (Cons (S (S (S Z))) Nil))
apply (rule eq)
  $\vdash$ sorted lte (Cons (S Z) (Cons (S (S (S Z))) Nil))
apply (rule cons)
  $\vdash$ lte (S Z) (S (S (S Z)))
* $\vdash$ sorted lte (Cons (S (S (S Z))) Nil)
apply (rule lt)
  $\vdash$ lte (S Z) (S (S Z))
* $\vdash$ sorted lte (Cons (S (S (S Z))) Nil)
apply (rule lt)
  $\vdash$ lte (S Z) (S Z)
* $\vdash$ sorted lte (Cons (S (S (S Z))) Nil)
apply (rule eq)
  $\vdash$ sorted lte (Cons (S (S (S Z))) Nil)
apply (rule uni)
done
\end{lstlisting}
\end{frame}



\begin{frame}
\frametitle{Analysis}
\begin{itemize}
\item communication classification: one-shot, one-to-many, many-to-one, many-to-many
\item control flow analysis
\item channel liveness
\item algorithm vs constraints
\item structural recursion vs fixpoint accumulation
\item performance improvements
\item safety
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Synchronization}
\begin{itemize}
\item uniprocessor; dispatch scheduling
\item multiprocessor; mutex and compare-and-swap
\item synchronization state
\item sender and receiver thread containers
\item message containers
\end{itemize}
\end{frame}


\end{document}
