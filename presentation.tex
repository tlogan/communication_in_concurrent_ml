\documentclass{beamer}

\usepackage[utf8]{inputenc}
 
\usepackage{listings}
\usepackage{color}
%
%\usepackage{graphicx}
%\graphicspath{ {./} }
%
\usepackage[T1]{fontenc}
\usepackage{libertine}
\usepackage[scaled=0.6]{beramono}
\usepackage[export]{adjustbox}

\lstset{
  basicstyle=\linespread{0.65}\ttfamily\small,
  breakatwhitespace=false,     
  breaklines=true,         
  captionpos=b,          
  keepspaces=true,         
  showspaces=false,        
  showstringspaces=false,
  showtabs=false,          
  tabsize=2,
}

\lstdefinelanguage{logic}{
  morekeywords={
    datatype,
    type,
    fun,
    val,
    predicate,
    where, only,
    if, then, else,
    and, or, not,
    lemma,
    theorem,
    of,
    have,
    assume, case, apply, done, by, proof, qed,
    goal
  },
  mathescape
}

\lstdefinelanguage{normal_lang}{
  morekeywords={
    bind, rslt, fun, app, unt, pair,
    mkChn, sync, fst, snd, lft, rht,
    spawn, case, of, sendEvt, recvEvt
  }
}

\lstdefinelanguage{sugar_lang}{
  morekeywords={
    datatype,
    type,
    fun,
    val,
    predicate,
    only, if, then, else,
    and, or, not,
    lemma,
    theorem,
    of,
    fun,
    bind, rslt, unt, pair,
    chn, lft, rht,
    sendEvt, recvEvt
  }
}

\title{A Mechanized Theory of Communication Analysis in CML}

%\usetheme{lucid}
\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
\frametitle{Concurrent ML}
\begin{itemize}
\item extension of Standard ML
\item concurrency and synchronization
\item synchronized communication over channels: send event, receive event
\item composition of events: choose event, wrap event ...
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Concurrent ML}
\begin{lstlisting}[language=ML]

type thread_id
val spawn : (unit -> unit) -> thread_id

type 'a chan
val channel : unit -> 'a chan

type 'a event
val sync: 'a event -> 'a

val recvEvt: 'a chan -> 'a event
val sendEvt: 'a channel * 'a -> unit event

val send: 'a chan * 'a -> unit
fun send (ch, v) = sync (sendEvt (ch, v))

val recv: 'a chan -> 'a
fun recv ch = sync (recvEvt ch)

\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Concurrent ML}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=ML, mathescape]
structure Serv : SERV =
struct 
  datatype serv =
    S of (int * int chan) chan

  fun make () =
  let 
    val reqCh = channel ()
    fun loop state =
    let
      val (v, replCh) = recv reqCh
      val () = send (replCh, state)
    in
      loop v
    end
    val () = spawn (fn () => loop 0)
  in
    S reqCh
  end 
\end{lstlisting}
\end{column}


\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=ML, mathescape]
  fun call (server, v) =
  let 
    val S reqCh = server
    val replCh = channel () 
    val () = send (reqCh, (v, replCh))
  in
    recv replCh
  end
end

signature SERV =
sig 
  type serv
  val make : unit -> serv
  val call : serv * int -> int
end
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}



\begin{frame}
\frametitle{Isabelle/HOL}
\begin{itemize}
\item interactive theorem proving assistant; proof assistant
\item unification and rewriting
\item simply typed terms
\item propositions as boolean typed terms
\item higher order terms
\item inductive data
\item computable recursive functions
\item inductive predicates
\item inductive reasoning
\item tactics and composition
\end{itemize}
\end{frame}



\begin{frame}[fragile]
	\frametitle{Isabelle/HOL}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=logic, mathescape]
$\vdash$ P1 $\vee$ P2 $\rightarrow$ Q
proof
  assume P1 $\vee$ P2:
    case P1:
      have $\vdash$ P1 $\rightarrow$ Q by A
      have $\vdash$ Q by modus ponens
    case P2:
      have $\vdash$ P2 $\rightarrow$ Q by B    
      have $\vdash$ Q by modus ponens
    have P1 $\vdash$ Q, P2 $\vdash$ Q
    have $\vdash$ Q by disjunction elimination
  have P1 $\vee$ P2 $\vdash$ Q
  have $\vdash$ P1 $\vee$ P2 $\rightarrow$ Q
    by implication introduction  
qed
\end{lstlisting}
\end{column}

\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=logic, mathescape]
$\vdash$ P1 $\vee$ P2 $\rightarrow$ Q
apply (rule impI)
  P1 $\vee$ P2 $\vdash$ Q
apply (erule disjE)
  P1 $\vdash$ Q
* P2 $\vdash$ Q
apply (insert A)
  P1, P1 $\rightarrow$ Q $\vdash$ Q
* P2 $\vdash$ Q
apply (erule mp)
  P1 $\vdash$ P1
* P2 $\vdash$ Q
apply assumption 
  P2 $\vdash$ Q
apply (insert B)
  P2, P2 $\rightarrow$ Q $\vdash$ Q
apply (erule mp)
  P2 $\vdash$ P2
apply assumption 
done
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}


\begin{frame}
\frametitle{Analysis}
\begin{itemize}
\item communication classification: one-shot, one-to-many, many-to-one, many-to-many
\item control flow analysis
\item channel liveness
\item algorithm vs constraints
\item structural recursion vs fixpoint accumulation
\item performance improvements
\item safety
\end{itemize}
\end{frame}



\begin{frame}[fragile]
\frametitle{Communication Classification}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=ML, mathescape]
structure Serv : SERV =
struct 

  datatype serv =
    S of (int * int chan) chan 

  fun make () =
  let 
    val reqCh = ManyToOne.channel ()
    fun loop state =
    let
      val (v, replCh) = ManyToOne.recv reqCh
      val () = OneShot.send (replCh, state)
    in
      loop v
    end
    val () = spawn (fn () => loop 0)
  in
    S reqCh
  end 
\end{lstlisting}
\end{column}


\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=ML, mathescape]
  fun call (server, v) =
  let 
    val S reqCh = server
    val replCh = OneShot.channel ()
    val () = ManyToOne.send (reqCh, (v, replCh))
  in
    OneShot.recv replCh
  end

end

val server = Serv.make ()

val () =
  spawn (fn () => Serv.call (server, 35));
  (spawn fn () => 
    Serv.call (server, 12); 
    Serv.call (server, 13)
  );
  spawn (fn () => Serv.call (server, 81));
  spawn (fn () => Serv.call (server, 44))
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}


\begin{frame}
\frametitle{Synchronization}
\begin{itemize}
\item uniprocessor; dispatch scheduling
\item multiprocessor; mutex and compare-and-swap
\item synchronization state
\item sender and receiver thread containers
\item message containers
\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Formal Mechanized Theory}
\begin{itemize}
\item Isabelle/HOL  
\item $\sim$ 1421 lines of definitions  
\item $\sim$ 3052 lines of completed proofs 
\item syntax-directed rules 
\end{itemize}
\end{frame}



\begin{frame}[fragile]
	\frametitle{Syntax}
\begin{lstlisting}[language=logic, mathescape]
datatype name = Nm string

datatype term = 
  Bind name complex term 
| Rslt name

and complex = 
  Unt
| MkChn
| Atom atom
| Spwn term 
| Sync name
| Fst name
| Snd name
| Case name name term name term 
| App name name

and atom = 
  SendEvt name name
| RecvEvt name
| Pair name name
| Lft name
| Rht name
| Fun name name term 
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
datatype dynamic_step =
  DSeq name
| DSpwn name
| DCll name
| DRtn name 

type dynamic_path = dynamic_step list

datatype chan =
  Chan dynamic_path name 

datatype dynamic_value = 
  VUnt
| VChn chan
| VAtm atom (name -> dynamic_value option)

type environment =
  name -> dynamic_value option
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
predicate seqEval: complex -> environment -> dynamic_value -> bool 
predicate callEval: complex -> env -> term -> env -> bool 

datatype contin = Ctn name tm env

type stack = contin list

datatype state = Stt program env stack 

type pool = dynamic_path -> state option

predicate leaf: pool -> dynamic_path -> bool

type corresp = dynamic_path * chan * dynamic_path

type communication = corresp set 

predicate dynamicEval: pool -> communication -> pool -> communication -> bool
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
predicate dynamicEval:
  pool -> communication -> pool -> communication -> bool
where

  return: pool path n env n$_k$ t$_k$ env$_k$ stack' v comm .
    leaf pool path,
    pool path = Some (Stt (Rslt n) env ((Ctn n$_k$ t$_k$ env$_k$) # stack')),
    env n = Some v
  $\vdash$ dynamicEval
    pool comm
    (pool(
      path @ [DRtn n] ->
        (Stt t$_k$ env$_k$(n$_k$ -> v) stack')
    ))
    comm

* seq: pool path n c t' env stack v .
    leaf pool path,
    pool path = Some (Stt (Bind n c t') env stack),
    seqEval c env v
  $\vdash$ dynamicEval
    pool comm
    (pool(
      path @ [DSeq n] -> (Stt t' (env(n -> v)) stack)
    ))
    comm
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
* call: pool path n c t' env stack t$_c$ env$_c$ comm .
    leaf pool path,
    pool path = Some (Stt (Bind n c t') env stack),
    callEval c env t$_c$ env$_c$
  $\vdash$ dynamicEval
    pool comm
    (pool(
      path @ [DCll n] -> (Stt t$_c$ env$_c$ ((Ctn n t' env) # stack))
    )) comm

* makeChan: pool path n t' env stack .
    leaf pool path,
    pool path = Some (Stt (Bind n MkChn t') env stack)
  $\vdash$ dynamicEval pool comm 
    (pool(
      path @ [DSeq n] ->
        (Stt t' (env(n -> (VChn (Chan path n)))) stack)
    )) comm

* spawn: pool path n t$_c$ t' env stack comm .
    leaf pool path, 
    pool path = Some (Stt (Bind n (Spwn t$_c$) t') env stack)
  $\vdash$ dynamicEval pool comm 
    (pool(
      path @ [DSeq n] -> (Stt t' (env(n -> VUnt)) stack),
      path @ [DSpwn n] -> (Stt t$_c$ env [])
    )) comm
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Semantics}
\begin{lstlisting}[language=logic, mathescape]
* sync: pool path$_s$ n$_s$ n$_{se}$ t$_s$ env$_s$ stack$_s$ n$_{sc}$ n$_m$
  env$_{se}$ path$_r$ n$_r$ n$_{re}$ t$_r$ env$_r$ stack$_r$ n$_{rc}$ env$_{re}$ chan comm .
    leaf pool path$_s$,
    pool path$_s$ = Some (Stt (Bind n$_s$ (Sync n$_{se}$) t$_s$) env$_s$ stack$_s$),
    env$_s$ n$_{se}$ = Some (VAtm (SendEvt n$_{sc}$ n$_m$) env$_{se}$),
    leaf pool path$_r$,
    pool path$_r$ = Some (Stt (Bind n$_r$ (Sync n$_{re}$) t$_r$) env$_r$ stack$_r$),
    env$_r$ n$_{re}$ = Some (VAtm (RecvEvt n$_{rc}$) env$_{re}$),
    env$_{se}$ n$_{sc}$ = Some (VChn chan),
    env$_{re}$ n$_{rc}$ = Some (VChn chan), 
    env$_{se}$ n$_m$ = Some v$_m$
  $\vdash$ dynamicEval
    pool comm
    (pool(
      path$_s$ @ [DSeq n$_s$] -> (Stt t$_s$ (env$_s$(n$_s$ -> VUnt)) stack$_s$), 
      path$_r$ @ [DSeq n$_r$] -> (Stt t$_r$ (env$_r$(n$_r$ -> v$_m$)) stack$_r$)
    )) 
    (comm $\cup$ {(path$_s$, chan, path$_r$)})
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Communication}
\begin{lstlisting}[language=logic, mathescape]
predicate isSendPath: pool -> chan -> dynamic_path -> bool where
  intro: pool path n n$_e$ t' env stack n$_{sc}$ n$_m$ env$_e$ chan .
    pool path = Some (Stt (Bind n (Sync n$_e$) t') env stack),
    env n$_e$ = Some (VAtm (SendEvt n$_{sc}$ n$_m$) env$_e$), 
    env$_e$ n$_{sc}$ = Some (VChn chan)
  $\vdash$ isSendPath pool chan path

predicate isRecvPath: pool -> chan -> dynamic_path -> bool where
  intro: pool path n n$_e$ t' env stack n$_{rc}$ env$_e$ chan .
    pool path = Some (Stt (Bind n (Sync n$_e$) t') env stack),
    env n$_e$ = Some (VAtm (RecvEvt n$_{rc}$) env$_e$),
    env$_e$ n$_{rc}$ = Some (VChn chan)
  $\vdash$ isRecvPath pool chan path

predicate forEveryTwo: ('a -> bool) -> ('a -> 'a -> bool) -> bool where
  intro: p r .
    $\forall$ path1 path2 .
      p path1 $\wedge$ p path2 $\rightarrow$ r path1 path2
  $\vdash$ forEveryTwo p r

predicate ordered: 'a list -> 'a list -> bool where
  first: path1 path2 .
    prefix path1 path2
  $\vdash$ ordered path1 path2
* second: path2 path1 .
    prefix path2 path1
  $\vdash$ ordered path1 path2
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Communication}
\begin{lstlisting}[language=logic, mathescape]
predicate oneToMany: tm -> chan -> bool where
  intro: t$_0$ chan .
    star dynamicEval [[] -> (Stt t$_0$ [->] [])] {} pool comm,
    forEveryTwo (isSendPath pool chan) ordered
  $\vdash$ oneToMany pool chan

predicate manyToOne: tm -> chan -> bool where
  intro: t$_0$ chan .
    star dynamicEval [[] -> (Stt t$_0$ [->] [])] {} pool comm,
    forEveryTwo (isRecvPath pool chan) ordered
  $\vdash$ manyToOne t$_0$ chan

predicate oneToOne: tm -> chan -> bool where
  intro: t$_0$ chan .
    star dynamicEval [[] -> (Stt t$_0$ [->] [])] {} pool comm,
    forEveryTwo (isSendPath pool chan) ordered,
    forEveryTwo (isRecvPath pool chan) ordered
  $\vdash$ oneToOne t$_0$ chan

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Dynamic Communication}
\begin{lstlisting}[language=logic, mathescape]
predicate oneShot: tm -> chan -> bool where
  intro: t$_0$ chan .
    star dynamicEval [[] -> (Stt t$_0$ [->] [])] {} pool comm,
    forEveryTwo (isSendPath pool chan) (op =)
  $\vdash$ oneShot t$_0$ chan

predicate oneSync: tm -> chan -> bool where
  intro: t$_0$ chan .
    star dynamicEval [[] -> (Stt t$_0$ [->] [])] {} pool comm,
    forEveryTwo (isSendPath pool chan) (op =),
    forEveryTwo (isRecvPath pool chan) ordered 
  $\vdash$ oneSync t$_0$  chan
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Static Semantics}
\begin{lstlisting}[language=logic, mathescape]
predicate staticEval:
  static_value_map -> static_value_map -> term -> bool
where

  result: staticEnv staticComm n .
  $\vdash$ staticEval staticEnv staticComm (Rslt n)

* unit: staticEnv n staticComm t' .
    SUnt $\in$ staticEnv n,
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n Unt t')

* makeChan: n staticEnv staticComm t' .
    (SChn n) $\in$ staticEnv n,
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n MkChn t')

* sendEvt: n$_c$ n$_m$ staticEnv n staticComm t' .
    (SAtm (SendEvt n$_c$ n$_m$)) $\in$ staticEnv n,
    staticEval staticEnv staticComm t' 
  $\vdash$ staticEval staticEnv staticComm (Bind n (Atom (SendEvt n$_c$ n$_m$)) t')

* recvEvt: n$_c$ staticEnv n staticComm t' . 
    (SAtm (RecvEvt n$_c$)) $\in$ staticEnv n,
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n (Atom (RecvEvt n$_c$)) t')
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Static Semantics}
\begin{lstlisting}[language=logic, mathescape]
* pair: n$_1$ n$_2$ staticEnv n staticComm t' .
    (SAtm (Pair n$_1$ n$_2$)) $\in$ staticEnv n,
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n (Atom (Pair n$_1$ n$_2$)) t')

* left: n$_a$ staticEnv n staticComm t' .
    (SAtm(Lft n$_a$)) $\in$ staticEnv n,
    staticEval staticEnv staticComm t' 
  $\vdash$ staticEval staticEnv staticComm (Bind n (Atom (Lft n$_a$)) t')

* right: n$_a$ staticEnv n staticComm t' .
    (SAtm(Rht n$_a$)) $\in$ staticEnv n, 
    staticEval staticEnv staticComm t
  $\vdash$ staticEval staticEnv staticComm (Bind n (Atom (Rht n$_a$)) t')

* function: n$_f$ n$_t$ t$_b$ staticEnv staticComm n t' .
    (SAtm (Fun n$_f$ n$_t$ t$_b$)) $\in$ staticEnv n$_f$, 
    staticEval staticEnv staticComm t$_b$, 
    (SAtm (Fun n$_f$ n$_t$ t$_b$)) $\in$ staticEnv n, 
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n (Atom (Fun n$_f$ n$_t$ t$_b$)) t')

* spawn: n$_f$ n$_t$ t$_b$ staticEnv staticComm n t' .
    SUnt $\in$ staticEnv n, 
    staticEval staticEnv staticComm t$_c$, 
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n (Spwn t$_c$) t')
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Static Semantics}
\begin{lstlisting}[language=logic, mathescape]
* sync: staticEnv n$_e$ n staticComm  t'.
    $\forall$ n$_{sc}$ n$_m$ n$_c$ . 
      (SAtm (SendEvt n$_{sc}$ n$_m$)) $\in$ staticEnv n$_e$
    $\rightarrow$ SChn n$_c$ $\in$ staticEnv n$_{sc}$ 
    $\rightarrow$ SUnt $\in$ staticEnv n $\wedge$ staticEnv n$_m$ $\subseteq$ staticComm n$_c$,
    $\forall$ n$_{rc}$ n$_c$ . 
      (SAtm (RecvEvt n$_{rc}$)) $\in$ staticEnv n$_e$
    $\rightarrow$ SChn n$_c$ $\in$ staticEnv n$_{rc}$ 
    $\rightarrow$ staticComm n$_c$ $\subseteq$ staticEnv n,
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n (Sync n$_e$) t')

* first: staticEnv n$_t$ n staticComm t' . 
    $\forall$ n$_1$ n$_2$ .
      (SAtm (Pair n$_1$ n$_2$)) $\in$ staticEnv n$_t$
    $\rightarrow$ staticEnv n$_1$ $\subseteq$ staticEnv n,
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n (Fst n$_t$) t')

* second: staticEnv n$_t$ n staticComm t' . 
    $\forall$ n$_1$ n$_2$ . 
      (SAtm (Pair n$_1$ n$_2$)) $\in$ staticEnv n$_t$
    $\rightarrow$ staticEnv n$_2$ $\subseteq$ staticEnv n,
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n (Snd n$_t$) t')

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Static Semantics}
\begin{lstlisting}[language=logic, mathescape]
* distinction: staticEnv n$_s$ n$_l$ t$_l$ n staticComm n$_r$ t$_r$ t' . 
    $\forall$ n$_c$ . 
      (SAtm (Lft n$_c$)) $\in$ staticEnv n$_s$
    $\rightarrow$ staticEnv n$_c$ $\subseteq$ staticEnv n$_l$,
    staticEnv (resultName t$_l$) $\subseteq$ staticEnv n,
    staticEval staticEnv staticComm t$_l$,
    $\forall$ n$_c$ . 
      (SAtm (Rht n$_c$)) $\in$ staticEnv n$_s$
    $\rightarrow$ staticEnv n$_c$ $\subseteq$ staticEnv n$_r$, 
    staticEnv (resultName t$_r$) $\subseteq$ staticEnv n, 
    staticEval staticEnv staticComm t$_r$,
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n (Case n$_s$ n$_l$ t$_l$ n$_r$ t$_r$) t')

* application: staticEnv n$_f$ n$_a$ n staticComm t' . 
    $\forall$ n$_f$' n$_t$ t$_b$ . 
      (SAtm (Fun n$_f$' n$_t$ t$_b$)) $\in$ staticEnv n$_f$
    $\rightarrow$ staticEnv n$_a$ $\subseteq$ staticEnv n$_t$, 
    staticEnv (resultName t$_b$) $\subseteq$ staticEnv n),
    staticEval staticEnv staticComm t'
  $\vdash$ staticEval staticEnv staticComm (Bind n (App n$_f$ n$_a$) t')
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Static Semantics}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=normal_lang, mathescape]
bind u1 = unt
bind r1 = rht u1
bind l1 = lft r1
bind l2 = lft l1

bind mksr = fun _ x2 => 
(
  bind k1 = mkChn
  bind srv = fun srv' x3 =>
  (
    bind e1 = recvEvt k1
    bind p1 = sync e1
    bind v1 = fst p1
    bind k2 = snd p1 
    bind e2 = sendEvt k2 x3
    bind z5 = sync e2
    bind z6 = app srv' v1
    rslt z6 
  )
  bind z7 = spawn
  (
    bind z8 = app srv r1
    rslt z8 
  )
  rslt k1
)
\end{lstlisting}
\end{column}

\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=normal_lang, mathescape]
bind rqst = fun _ x4 =>
(
  bind k3 = fst x4
  bind v2 = snd x4
  bind k4 = mkChn
  bind p2 = pair v2 k4
  bind e3 = sendEvt k3 p2
  bind z9 = sync e3
  bind e4 = recvEvt k4
  bind v3 = sync e4
  rslt v3
)

bind srvr = mksr u1
bind z10 = spawn
( 
  bind p3 = pair srvr l1
  bind z11 = app rqst p3
  rslt z11
)
bind p4 = pair srvr l2
bind z12 = app rqst p4
rslt z12
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}



\begin{frame}[fragile]
	\frametitle{Static Semantics}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=sugar_lang, mathescape]
val staticEnv: name -> static_value set =
(
  u1 -> {unt},
  r1 -> {rht u1},
  l1 -> {lft r1},
  l2 -> {lft l1},
  mksr -> {fun  _ x2 => ...},
  x2 -> {unt},
  k1 -> {chn k1},
  srv -> {fun srv' x3 => ...},
  srv' -> {fun srv' x3 => ...},
  x3 -> {rht u1, lft r1, lft l1},
  e1 -> {recvEvt k1},
  p1 -> {pair v2 k4},
  v1 -> {lft r1, lft l1},
  k2 -> {chn k4},
  e2 -> {sendEvt k2 x3},
  z5 -> {unt},
  z7 -> {unt},
  u5 -> {unt},
  rqst -> {fun _ x4 => ...},
\end{lstlisting}
\end{column}

\begin{column}{0.5\textwidth}
\begin{lstlisting}[language=sugar_lang, mathescape]
  x4 -> {pair srvr l1, pair srvr l2},
  k3 -> {chn k1},
  v2 -> {lft r1, lft l1},
  k4 -> {chn k4},
  p2 -> {pair v2 k4},
  e3 -> {sendEvt k3 p2},
  z9 -> {unt},
  e4 -> {recvEvt k4},
  v3 -> {rht u1, lft r1, lft r2},
  srvr -> {chn k1},
  z10 -> {unt},
  p3 -> {pair srvr l1},
  z11 -> {rht u1, lft r2},
  p4 -> {pair srvr l2},
  z12 -> {rht u1, lft l1}
)

val staticComm: name -> static_value set =
(
  k1 -> {pair v2 k4},
  k4 -> {rht u1, lft l1, lft l2}
)
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Static Communication}
\begin{lstlisting}[language=logic, mathescape]
predicate staticOneToMany: term -> name -> bool where
  intro: staticEnv staticComm t graph n$_c$ .
    staticEval staticEnv staticComm t,
    staticFlowsAccept staticEnv graph t,
    forEveryTwo (staticTraceable graph (termId t)
      (staticSendId staticEnv t n$_c$)) uncompetitive
  $\vdash$ staticOneToMany t n$_c$

predicate staticManyToOne: term -> name -> bool where
  intro: staticEnv statcComm t graph n$_c$ .
    staticEval staticEnv staticComm t,
    staticFlowsAccept staticEnv graph t,
    forEveryTwo (staticTraceable graph (termId t)
      (staticRecvId staticEnv t n$_c$)) uncompetitive
  $\vdash$ staticManyToOne t n$_c$
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Static Communication}
\begin{lstlisting}[language=logic, mathescape]
predicate staticOneShot: term -> name -> bool where
  intro: staticEnv staticComm t graph n$_c$ .
    staticEval staticEnv staticComm t,
    staticFlowsAccept staticEnv graph t,
    forEveryTwo (staticTraceable graph (termId t)
      (staticSendId staticEnv t n$_c$)) singular
  $\vdash$ staticOneShot t n$_c$

predicate staticOneSync: term -> name -> bool where
  intro: staticEnv staticComm t graph n$_c$ .
    staticEval staticEnv staticComm t,
    staticFlowsAccept staticEnv graph t,
    forEveryTwo (staticTraceable graph (termId t) (staticSendId staticEnv t n$_c$)) singular,
    forEveryTwo (staticTraceable graph (termId t) (staticRecvId staticEnv t n$_c$)) uncompetitive
  $\vdash$ staticOneSync t n$_c$
\end{lstlisting}
\end{frame}


\begin{frame}
\frametitle{Soundness}
\begin{itemize}
\item induction on transition system 
\item generalization to intermediate semantic data structures 
\item skewing of induction direction
\item reversing of inference direction  
\item preservation
\end{itemize}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Soundness}
\begin{lstlisting}[language=logic, mathescape]
theorem staticOneToManySound: t$_0$ n$_c$ path$_c$ . 
  staticOneToMany t$_0$ n$_c$
$\vdash$ oneToMany t$_0$ (Chan path$_c$ n$_c$)

theorem staticManyToOneSound: t$_0$ n$_c$ path$_c$ . 
  staticManyToOne t$_0$ n$_c$
$\vdash$ manyToOne t$_0$ (Chan path$_c$ n$_c$)

theorem staticOneToOneSound: t$_0$ n$_c$ path$_c$ . 
  staticOneToOne staticEnv t$_0$ n$_c$
$\vdash$ oneToOne t$_0$ (Chan path$_c$ n$_c$)

theorem staticOneShotSound: t$_0$ n$_c$ path$_c$ .
  staticOneShot t$_0$ n$_c$
$\vdash$ oneShot t$_0$ (Chan path$_c$ n$_c$)

theorem staticOneShotSound: t$_0$ n$_c$ path$_c$ .
  staticOneSync t$_0$ n$_c$
$\vdash$ oneSync t$_0$ (Chan path$_c$ n$_c$)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
	\frametitle{Soundness}
\begin{lstlisting}[language=logic, mathescape]
lemma staticEvalSound: t$_0$ pool comm staticEnv staticComm path t env stack n v .
  staticEval staticEnv staticComm t$_0$, 
  star dynamicEval [[] -> (Stt t$_0$ [->] [])] {} pool comm,
  pool path = Some (Stt t env stack), 
  env n = Some v
$\vdash$ abstract v $\in$ staticEnv n 
\end{lstlisting}
\end{frame}


\begin{frame}
\frametitle{Higher Precision Analysis}
\begin{itemize}
\item different channel instances with same name  
\item channel liveness analysis
\item trimmed graph
\item paths from channel creation site
\item paths along sending transitions 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Higher Precision Analysis}
\includegraphics[width=.7\textwidth]{cml-graph-lp.pdf}
\end{frame}

\begin{frame}
\frametitle{Higher Precision Analysis}
\includegraphics[width=.7\textwidth]{cml-liveness-analysis-k1.pdf}
\end{frame}

\begin{frame}
\frametitle{Higher Precision Analysis}
\includegraphics[width=0.7\textwidth]{cml-graph-k1.pdf}
\end{frame}

\begin{frame}
\frametitle{Higher Precision Analysis}
\includegraphics[width=.72\textwidth]{cml-liveness-analysis-k4.pdf}
\end{frame}

\begin{frame}
\frametitle{Higher Precision Analysis}
\includegraphics[width=0.6\textwidth]{cml-graph-k4.pdf}
\end{frame}



\begin{frame}[fragile]
	\frametitle{Higher Precision Analysis}
\begin{lstlisting}[language=logic, mathescape]
predicate staticOneToMany: term -> name -> bool where
  intro: staticEnv staticComm t graph entr exit n$_c$ 
    staticEval staticEnv staticComm t,
    staticFlowsAccept staticEnv graph t,
    staticChanLive staticEnv entr exit n$_c$ t, 
    forEveryTwo (staticTraceable graph entr exit (IdBind n$_c$)
      (staticSendId staticEnv t n$_c$)) uncompetitive
  $\vdash$ staticOneToMany t n$_c$

predicate staticManyToOne: term -> name -> bool where
  intro: staticEnv staticComm t graph entr exit n$_c$ 
    staticEval staticEnv staticComm t,
    staticFlowsAccept staticEnv graph t,
    staticChanLive staticEnv entr exit n$_c$ t, 
    forEveryTwo (staticTraceable graph entr exit (IdBind n$_c$)
      (staticRecvId staticEnv t n$_c$)) uncompetitive
  $\vdash$ staticManyToOne t n$_c$
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Higher Precision Analysis}
\begin{lstlisting}[language=logic, mathescape]

predicate staticOneToOne: term -> name -> bool where
  intro: staticEnv staticComm t graph entr exit n$_c$ 
    staticEval staticEnv staticComm t,
    staticFlowsAccept staticEnv graph t,
    staticChanLive staticEnv entr exit n$_c$ t, 
    forEveryTwo (staticTraceable graph entr exit (IdBind n$_c$) 
      (staticSendId staticEnv t n$_c$)) uncompetitive, 
    forEveryTwo (staticTraceable graph entr exit (IdBind n$_c$)
      (staticRecvId staticEnv t n$_c$)) uncompetitive
  $\vdash$ staticOneToOne t n$_c$

predicate staticOneShot: term -> name -> bool where
  intro: staticEnv staticComm t graph entr exit n$_c$ . 
    staticEval staticEnv staticComm t,
    staticFlowsAccept staticEnv graph t,
    staticChanLive staticEnv entr exit n$_c$ t, 
    forEveryTwo (staticTraceable graph entr exit (IdBind n$_c$)
      (staticSendId staticEnv t n$_c$)) singular
  $\vdash$ staticOneShot t n$_c$
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Discussion}
\end{frame}

\end{document}
