\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}



\usepackage[utf8]{inputenc}
 
\usepackage{listings}
\usepackage{color}
 
\iffalse
  \definecolor{codegreen}{rgb}{0,0.6,0}
  \definecolor{codegray}{rgb}{0.5,0.5,0.5}
  \definecolor{codepurple}{rgb}{0.58,0,0.82}
  \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
  backgroundcolor=\color{backcolour},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\small\color{codegray},
  stringstyle=\color{codepurple},
\fi
 
\lstdefinestyle{codestyle1}{
  basicstyle=\ttfamily\small,
  breakatwhitespace=false,     
  breaklines=true,         
  captionpos=b,          
  keepspaces=true,         
  numbers=left,          
  numbersep=5pt,          
  showspaces=false,        
  showstringspaces=false,
  showtabs=false,          
  tabsize=2
}
 




\title{Formal Theory of Communication Topology in Concurrent ML}
\author{Thomas Logan}
\begin{document}

\maketitle
\pagenumbering{gobble}

\newpage
\pagenumbering{arabic}


\section{Summary}
The goal of this master's thesis is to the develop formal and mechanically verified proofs of
useful properties about communication in Concurrent ML[8, 9].  This work will build on Reppy
and Xiao's static analysis for computing sound approximations of communication
topologies[11, 16].  I will define a small-step operational semantics for Concurrent ML and a
constraint-based static analysis[5] that describes all possible communications with varying
precision.  I will prove that the analysis is sound with respect to the semantics.  The
semantics, analysis, propositions, proofs, and theorems will rely on Isabelle/HOL[6, 7, 14, 15]
as the formal language of reasoning.  The proofs will be mechanically checked by Isabelle[17].


\section{Overview}
Concurrent programming languages provide features to specify a range of evaluation orders
between steps of distinct expressions.  The freedom to choose from a number of possible
evaluation orders has certain advantages.  Conceptually distinct tasks may need to overlap in
time, but are easier to understand if they are written as distinct expressions.  Concurrent
languages may also allow the evaluation order between steps of expressions to be
nondeterministic or unrestricted.  If it's not necessary for tasks to be ordered in a precise
way, then it may be better that the program allow arbitrary ordering and let a scheduler find
an execution order based on runtime conditions and policies of fairness.  A common use case for
concurrent languages is GUI programming, in which a program has to process various requests
while remaining responsive to subsequent user inputs and continually providing the user with
the latest information it has processed. Concurrent ML is a concurrent programming language.
It offers a thread abstraction, which is a piece of code allowed to have a wide range of
evaluation orders relative to code encapsulated in other threads.  The language provides a
synchronization mechanism that can specify the execution order between parts of expressions in
separate threads.  It is often the case that synchronization is necessary when data is shared.
Thus, in Concurrent ML, synchronization and data sharing mechanisms are actually subsumed by a
uniform communication mechanism.  Additional thread abstractions can be used for sharing data
asynchronously, which can provide better usability or performance in some instances. A thread
in Concurrent ML, is created using the spawn primitive.

Threads communicate by having shared access to a common channel.  A channel can be used to
either send data or receive data.  When a thread sends on a channel, another thread must
receive on the same channel before the sending thread can continue.  Likewise, when a thread
receives on a channel, another thread must send on the same channel before the receiving thread
can continue.

A given channel can have any arbitrary number of threads sending or receiving data on it over
the course of the program's execution.  Listing 1 and Listing 2 give a simple example derived
from Reppy's book Concurrent Programming in ML[8] that illustrates these essential features of
Concurrent ML.

The server implementation, given in Listing 2, defines a server that holds a number state.
When a client gives the server a number v, the server gives back state, and holds onto v to as
its new state, which it gives to the next client and so on.  A request and reply is equivalent
to reading and writing a mutable cell in isolation.  The function make makes a new server.  It
creates a new channel reqCh, from which the server will receive requests.  The sever behavior
is defined by the infinite loop loop, which takes a number as the state of each iteration.
Each iteration, the server tries to receive requests on reqCh.  It expects the request to be
composed of a number v and a channel replCh, through which to reply.  Once a request has been
received, it sends the current state back to the client through replCh by calling
send (replCh, state).  It initiates the next iteration of the loop by calling loop with a new
state from the client.  The server is created with a new thread by calling
spawn (fn () => loop 0).   A handle to the new server is returned as reqCh wrapped in the
constructor S.  The function call makes a request to a server server with a number v and
returns the number from the server's reply.  It extracts the request channel reqCh from the
server handle and creates a new channel replCh, from which the client will receive replies.
It makes a request to the server with the number v and the reply channel replCh by calling
send (reqCh, (v, replCh)).  Then it receives the reply with the new number by calling recv
replCh.

Reppy's original design of Concurrent ML allows for events other than sending and receiving to
be triggered by synchronization.  One such event chooses between one of many events to
synchronize on.  Only one of the events is chosen for synchronization, but all choices must be
represented.  Thus, event synchronization must be separated from event values, similar to the
way function application is separated from function abstraction.  send and recv are just
shorthand for synchronization on send and receive events, respectively.


choose is an example of an event combinator; a way to construct an event from other events.
Reppy's book on Concurrent ML offers explanations of many other useful combinators, such as the
wrap and guard combinators[8].  Donnelly and Fluet extended Concurrent ML with the
transactional event combinator thenEvt[1].  Transactional events provide a technique for
describing tasks that sometimes execute in isolation and sometimes don't.  Achieving similar
results without transactional events would require duplication of code in multiple threads,
resulting in code that is brittle under modification.

When  thenEvt is synchronized on, either all of its constituent events and abstractions
evaluate in isolation, or none evaluate.


A uniprocessor implementation of synchronous communication is inexpensive.  Using a fairly
course-grain interleaving, the communication on a channel can proceed by checking if the
channel is in one of two possible states: either a corresponding thread is waiting or there's
nothing waiting.  The implementation doesn't need to consider states where competing threads
are also trying to communicate on the same channel, since the course-grain interleaving ensures
that competing threads have made no partial communication progress.  In a multiprocessor
setting, threads can run in parallel and multiple threads can simultaneously make partial
progress on the same channel.  The multiprocessor implementation of communication is more
expensive than that of the uniprocessor, since it must consider additional states related to
competing threads making partial communication progress.[10]

Channels known to have only one sender or one receiver can have lower communication costs than
those with arbitrary number of senders and arbitrary number of receivers, since some of the
cost of handling competing threads can be avoided.  Concurrent ML does not provide language
features for multiple types of channels distinguished by their communication topologies, or the
number of threads that may end up sending or receiving on it.  However, channels can be
classified into various topologies based on their potential communication.  A many-to-many
channel has any number of senders and receivers; a fan-out channel has one sender and any
number of receivers; a fan-in channel has any number of senders and exactly one receiver; a
one-to-one channel has exactly one of each; a one-shot channel has exactly one sender, one
receiver, and sends data only once.  The server implementation in Listing 2  with the following
calling code exhibits these topologies.


Since there are four threads that make calls to the server, the server's particular reqCh has
four senders.  Servers are created with only one thread listening for requests, so the reqCh of
this server has just one receiver.  So the server's reqCh is classified as fan-in.  Each use of
call creates a distinct new channel replCh for receiving data.  The function call receives on
the channel once and the server sends on the channel once, so each instance of replCh is
one-shot.

A program analysis that describes communication topologies of channels has practical benefits
in at least two ways.  It can highlight which channels are candidates for optimized
implementations of communication; or in a language extension allowing the specification of
restricted channels, it can conservatively verify the correct usage of restricted channels.
Listing 2 demonstrates the language extension based on an example from Reppy and Xiao[11].


Without a static analysis to check the usage of the special channels, one could inadvertently
use a one-shot channel for a channel that has multiple senders, resulting in runtime behavior
inconsistent with the general semantics of channel synchronization.

The utility of the program analysis additionally depends on it being informative, sound, and
computable.  The analysis is informative iff there exist programs about which the analysis
describes information that is not directly observable.  The analysis is sound iff the
information it describes about a program is the same or less precise than the operational
semantics of the program. The analysis is computable iff there exists an algorithm that
determines all the values described by the analysis on any input program.

Program analyses, like operational semantics, describe information about the execution or
behavior of programs.  Yet, while an operational semantics may be viewed as ground truth, the
correctness of an analysis is derived from its relation to an operational semantics.  In
practice, program analyses often describe computable information with respect to operational
semantics that are universal and capable of describing uncomputable information.  To allow for
computability, program analyses often describe approximate information.

There are a large number of program analyses with a variety of practical uses.  Some
constructions of programs might be considered bad, by describing operations that don't make
sense, like True * 5 / “hello”, or accessing the 7th element of an array with 6 elements.  A
type systems, or static semantics, is an analysis that can help ensure programs are well
constructed.  It describes how programs and expressions can be composed, such that the programs
won't get stuck or result in certain kinds of undesired behavior.  Type systems can improve
debugging by pointing out errors that may be infrequently executed.  They can also improve
execution speeds of safe languages by rendering some runtime checks unnecessary.  

Other analyses are useful for describing opportunities for program optimizations.  Many
analyses used for optimizations describe how data flows with information related to every point
in the program.  Each point refers to a term, from which the small-step semantics may take a
step.  Some programs may mention the same expression multiple times, possibly resulting in
redundant computations.  These redundant computations can be detected by available expressions
analysis, one of many data flow analyses.  An available expressions analysis describes which
expressions must have been computed by each program point.

The expression (!x + 1) is available by line 9 but (!y + 2) and (w - 3) are not, because y was
modified in line 8 and w was rebound in line 6. Another inefficiency is that programs may
perform computations, but then ignore their results.  Such dead code can be detected by a
liveness analysis.  The analysis describes for each program point, the set of variables and
references whose values might be used in the remainder of the program.

Since the variables x and z and the dereference !z are used in line 8, they are live at line
7.  Since z is reassigned at line 7, !z is no longer live at line 6.  Since x is bound at line
5 and not used above, it is not live at line 4 and above.  Since z is bound at 4 and not used
above, it is not live at line 3 and above. The liveness information demonstrates that the
expression (4 * 73) doesn't need to be computed, and lines 2 and 3 can simply be removed.

The information at each program point is derived from control structures in the program that
dictate how information may flow between program points.  Some uses of control structures are
represented as literals in the syntax, while other uses are expressions that may evaluate to
control structures, or function parameters that may bind to control structures.  Function
abstraction is a control structure allowing multiple parts of a program to flow into a section
of code via a binding.  In ML, function abstractions are higher order, and may be unknown
without some form of evaluation.  These control structures may be revealed by an abstract value
flow analysis, which associates each program point with a set of abstract values that the
point's expression may evaluate to.


The abstract values of f, g, h are simply their let bound expressions {fn x => x 1},
{fn y => y + 2},  {fn z => z + 3}, respectively.  x has the abstract values of
{fn y => y + 2, fn z => z + 3}, so x 1 has the abstract values of {3, 4}; (f g) has abstract
values of {3, 4}.  Since the abstract values depend on the flow of information, which depends
on the abstract values, the description of abstract values is inductive or recursive.  The
historical motivation for describing the abstract value information was really for its the
control information, so the original approaches to these analyses are known as control flow
analyses or CFAs.  With the control flow information, other data flow analyses like available
expression analysis and liveness analysis can provide greater coverage.

Analyses can be described in a variety of ways.  An algorithm that take programs as input and
produce behavior information as output are necessary for automation in compilers.  A
specification that states a proposition in terms of programs and execution information may be
more suitable for showing clarity of meaning and correctness with respect to the operational
semantics.  The specification can be translated into an algorithm involving two parts.  The
first part generates a comprehensive set of data structures representing constraints of all
program points, mirroring the specification's description, and the second part solves the
constraints.

For a subset of Concurrent ML without event combinators, Reppy and  Xiao developed an
efficient algorithmic analysis that determines for each channel all abstract threads that send
and receive on it.  The algorithm depends on each primitive operation in the program being
labeled with a program point.  A sequence of program points ordered in a valid execution
sequence forms a control path.  Distinction between threads in a program can be inferred from
whether or not their control paths diverge.  

The algorithm proceeds in multiple steps that produce intermediate data structures, used for
efficient lookup in the subsequent steps.  It starts with a control-flow analysis[12, 13] that
results in multiple mappings. One mapping is from variables to abstract values that may bind to
the variables.  Another mapping is from channel-bound variables to abstract values that are
sent on the respective channels.  Another is from function-bound variables to abstract values
that are the result of respective function applications.  It constructs a control-flow graph
with possible paths for pattern matching and thread spawning determined directly from the
primitives used in the program.  Relying on information from the mappings to abstract values,
it constructs the possible paths of execution via function application and channel
communication.  It uses the graph for live variable analysis of channels, which limits the
scope for the remaining analysis.  Using the spawn and application edges of the control-flow
graph, the algorithm then performs a data-flow analysis to determine a mapping from program
points to all possible control paths leading into the respective program points.  Using the
CFA's mappings to abstract values, the algorithm determines the program points for sends and
receives per channel variable.  Then it uses the mapping to control paths to determine all
control paths that send or receive on each channel, from which it classifies channels as
one-shot, one-to-one, fan-in, fan-out, or many-to-many.

Reppy and Xiao informally prove soundness of their analysis by showing that their analysis
claims that more than one thread sends (or receives) on a channel if the execution allows more
than one to send (or receive) on a that channel.  The proof of soundness depends on the
ability to relate the execution of a program to the static analysis of a program.  The static
analysis describes threads in terms of control paths, since it can only describe threads in
terms of statically available information. Thus, in order to describe the relationship between
the threads of the static analysis and the operational semantics, the operational semantics is
defined as stepping between sets of control paths paired with terms.  Divergent control paths
are added whenever a new thread is spawned.

The syntax, semantics, and analysis need to describe many details.  Proving propositions
relating all of these definitions requires manipulation of all those details.  To ensure the
correctness of proofs, it is necessary to check that there are no subtle errors in the
definitions or proofs.  Proofs in general require many subtle manipulations of symbols.  The
difference between a false statement and a true statement can often be difficult to spot, since
the two may be very similar lexically.  However, a mechanical proof checker, such as the one in
Isabelle, has no difficulty discerning between valid and invalid derivations of statements.
Mechanical checking of proofs can notify us of errors in the proofs or definitions far better
and faster than manual checking.  I have already benefitted from Isabelle's proof checker in
order to correctly define the language semantics and abstract value flow analysis for this
work.  While trying to prove soundness of the analysis, the proof assistant would not accept my
proof unless I provided derivation of facts that I believed to be false.  I determined that my
intuition was correct but my definitions had errors.  After correcting the errors, I was able
to complete the proof, such that the proof checker was satisfied.

Although Isabelle is described as a proof assistant[17], it is really a generic system for
processing any kind of code.  The code could be proofs, propositions, programs, or types.  The
processing could be checking proofs, interpreting programs, or translating code.  Code and
logics for processing code are defined by users using its meta-language Standard ML, and other
user-defined languages.  Isabelle/HOL is a higher-order logic built from Isabelle's primitives
and other logics.  It is useful for both programming and proving.  Its ability to check that
proofs satisfy propositions is simply one instance of its verification capabilities.  It can
also check that program terms satisfy types, similar to other programming systems for ML.
Proofs and propositions are analogous to terms and types, respectively, yet Isabelle/HOL treats
the two concepts distinctly.  The practical uses for terms are quite different from that of
proofs.  If a term satisfies a type, then the term has utility for the data or computation it
represents.  The type is only valuable for confirming or denying the usage of a term.  In
contrast, once a proof satisfies a proposition, the proof becomes irrelevant, while the
proposition is elevated to a theorem.  The theorem is useful on its own without regard to any
particular proof.

Similar to other programming languages, type bool can be satisfied by values True or False. In
contrast to other programming languages, additional syntax, or data constructors, can be
defined to satisfy the type bool.  A constructor can take any number of terms of any types as
input in order to create a boolean term. Although these new terms could be used in programs,
just as True and False are, their main utility is in theorem proving.  In Isabelle/HOL,
propositions are isomorphic to terms of type bool.  The constructors are defined with a set of
inference rules, where each inference rule defines the conditions sufficient for a
construction to be valid, and at least one of the enumerated conditions is necessary for a
valid construction .  In other words, the constructor is equivalent to the boolean sum of all
the conditions.  The proposition definitions in terms of inference rules, or inductive
definitions, are analogous to datatype definitions, just as propositions are analogous to
types.


The definitions of list and sorted can be combined with definitions of natural numbers to form
propositions.  Note that Isabelle/HOL's list is defined with syntactic sugar. hd \# tl can be
used instead of Cons hd tl, and [a, b, c] is a \# b \# c \# Nil.  In Isabelle/HOL, propositions
may be proved by applying the inference rules.  The method rule is used to work backwards from
the goal until no further conditions need to be satisfied.  Theorems may also be proved
forwards from axioms, theorems or assumptions to the goal, using other methods like drule or
erule.


In truth, True and False are not primitive values, but actually just named instances of other
propositions converted to boolean terms.   False is defined to be the absurd statement that all
propositions are valid.


\section{Hypothesis}
I will derive a static analysis from Reppy and Xiao's algorithm, describing for each channel in
a program, all threads that possibly send or receive on the channel.  Additionally, it will
classify channels as one-shot, one-to-one, fan-out, fan-in, or many-to-many.  Instead of
Serrano's algorithm[18] for the CFA used in Reppy and Xiao's algorithm, I will define a
constraint-based specification and algorithm for the CFA.  The method of determining topologies
will be fairly similar to Reppy and Xiao's.  The analysis of this work will also consider event
combinators, which are not considered in Reppy and Xiao's work.  I will show that the static
analysis is informative by demonstrating programs for which the static analysis classifies some
channels as fan-in, fan-out, and so on.  I will show that the static analysis is sound by
showing that for any program, the execution of the program results in the same sends and
receives or fewer compared to the possible sends and receives described by the analysis.  I
will show that the static analysis is computable by demonstrating the existence of a
computable function that takes any program as input and generates all sends and receives
described by the analysis.


\section{Evaluation}
The main contributions of this work will be formal and mechanically verified proofs of
communication properties of Concurrent ML, including an analysis derived from Reppy and Xiao's
analysis.  This work extends that of Reppy and Xiao by demonstrating formal proofs of soundness
and extending the analysis to encompass event combinators for choice and transactions.


\section{Architecture}
To enable mechanical verification of the correctness of the proofs, I will construct the
semantics, analysis and theorems in the formal language of Isabelle/HOL.  To aid the
development of formal proofs, I will design the analysis as a declarative specification as
opposed to an algorithm.  However, the declarative analysis will make the proof of
computability less direct.  To aid the scrutiny of the theorems' adequacy, I will express the
definitions and propositions with the fewest number of structures, judgements, inferences rules
, and axioms necessary.  Efficiency of computation will be ignored in favor of verification.
I will not rely on intermediate map or graph data structures, which Reppy and Xiao used for
efficient computation.  In order to relate the analysis to the operational semantics, I will
borrow Reppy and Xiao's strategy of stepping between sets of control paths tied to terms.

In this thesis work, I'm interested in communication topology soundness, rather than flow
soundness.  Nevertheless, I will need to prove additional flow soundness theorems en route to
proving communication topology soundness.  Restricting the grammar to a form that requires
every abstraction and application to be bound to a variable would allow the operational
semantics to maintain static term information necessary for proofs of flow soundness[3, 5].
The semantics would be defined as an environment based operational semantics, rather than a
substitution based operational semantics.  By avoiding simplification of terms in the
operational semantics, it will be possible to relate the abstract values of the analysis to the
values produced by the operational semantics, which in turn is relied on to prove flow
soundness.


I will incorporate the restricted grammar and the environment based semantics into this work.
The restricted grammar is impractical for a programmer to write, yet it is still practical for
a language under automated analysis since there is a straight forward procedure to transform
more flexible grammars into the restricted form as demonstrated by Flanagan et al [2].
Additionally, the restricted grammar melds nicely with the control path semantics.  Instead of
defining additional meta-syntax for program points of primitive operations, I can simply use
the required variables of the restricted grammar to identify program points, and control paths
will simply be sequences of let bound variables. A modification of Listing 2 illustrates the
restrictive grammar applied to Concurrent ML.


\section{Implementation}
We describe possible implementations of specialized and unspecialized Concurrent ML using
feasible low-level thread-centric features such as wait and poll.  The thread-centric approach
allows us to focus on optimizations common to many implementations by decoupling the
implementation of communication features from thread scheduling and management.  Depending on
the low level features provided by existing language implementations, Concurrent ML could be
implemented in terms of lower level features, as is the case in SML/NJ and MLton.  It could
also be implemented as primitive features within a compiler and runtime or interpreter.
Analyzing and optimizing Concurrent ML would require treating the language as an object, so
implementing its features as primitives would make the most sense.  Thus, one can think of the
implementation shown here as an intermediate representation presented with concrete syntax.

The benefits of specialization would be much more significant ins multiprocessor
implementations rather than single processor implementations.  A single processor
implementation could avoid overhead caused by contention to acquire locks, by coupling the
implementation of channels with scheduling and only scheduling send and recv operations when no
other pending operations have yet to start or have already finished.  Reppy's implementation of
Concurrent ML uses SML/NJ's first class continuations to implement scheduling and communication
as one with low overhead.  However, a multiprocessor implementation would allow threads to run
on different processors for increased parallelism and would not be able to mandate when threads
are attempted relative to others without losing the parallel advantage.  The cost of trying to
achieve parallelism is increased overhead due to contention over acquiring locks.

A channel can be in one of three states.  Either some threads are trying to send through it,
some threads are trying to receive from it, or no threads are trying to send or receive.
Additionally a channel is composed of a mutex lock, so that send and recv operations can yield
to each other when updating the channel state.  When multiple threads are trying to send on a
channel, the channel is associated with a queue consisting of messages to be sent, along with
conditions waited on by sending threads. When multiple threads are trying to receive on a
channel, the channel is associated with a queue consisting of initially empty cells accessible
by receiving threads and conditions waited on by the receiving threads. The three states are
represented by the datatype chan\_content.  The channel is represented by the chan datatype,
which is composed of a reference to chan\_content and a mutex lock.  

The send operation acquires the channel's lock to ensure that it updates the channel based on
any one of its latest state.  If there are threads trying to receive from the channel, the send
operation dequeues an item from the state's associated queue.  The item consists of a condition
waited on by a receiving thread and an empty cell that can be accessed by the receiving thread.
It deposits the message in the cell and signals on the condition, updates the channel state to
inactive if there are no further receiving threads waiting, then releases the lock, signals on
the condition and returns the unit value.  If there are no threads trying to receive from the
channel, the send operation updates the channel state to that of trying to send with an
additional condition and message in the associated queue.  It releases the lock and waits on
the enqueued condition.  Once a receiving thread signals on the same condition, the send
operation returns with the unit value.

The recv operation acquires the channel's lock to ensure that it updates the channel based on
any one of its latest state.  If there are threads trying to send on the channel, the recv
operation dequeues an item from the state's associated queue.  The item consists of a condition
waited on by a sending thread along with a message to be sent.  It signals the condition and
updates the channel state to inactive if there are no further sending threads waiting, then
releases the lock and returns the sent message.  If there are no threads trying to send on the
channel, the recv operation updates the channel state to that of trying to receive with an
additional condition and empty cell in the associated queue.  It releases the lock and waits on
the enqueued condition.  Once a sending thread signals on the same condition, the recv
operation returns with the value deposited in the cell by a sending thread.


Implementation of fan-out channels, compared to that of many-to-many channels, requires fewer
steps to synchronize and can execute more steps outside of critical regions, which reduces
contention for locks.  A channel is composed of a lock and one of three possible states, as is
the case for many-to-many channels.  However, the state of a thread trying to send need only be
associated with one condition and one message.  

The send operation checks if the channel's state is inactive and tries to use the
compareAndSwap operator to transactionally update the state of the channel to that of trying to
send.  If successful, it simply waits on sendCond, the condition that a receiving thread will
signal on, and then returns the unit value.  If the transactional update fails and the state is
that of threads trying to receive on the channel, then the send operation acquires the lock,
then dequeues an item from the associated queue where the item consists of recvCond, a
condition waited on by a receiving thread, and a cell for depositing the message to that
receiving thread.  It deposits the message in the cell, updates the state to inactive there are
no further items on the queue, then releases the lock.  Then it signals on the condition and
returns the unit value. The lock is acquired after the state is determined to be that of
threads trying to receive, since the expectation is that the current thread is the only one
that tries to update the channel from that state.  If the communication topology analysis were
incorrect and and there were actually multiple threads that could call the send operation, then
there might be data races.  Likewise, due to the expectation of a single thread sending on the
channel, the send operation should never witness the state of threads already trying to send.

The recv operation acquires the lock and checks the state of the channel, just as the recv
operation for many-to-many channels.  If the channel is in a state where there is no already
trying to send, then it behaves the same as the recv operation of many-to-many channels. If
there is already a thread trying to receive, then it updates the state to inactive and releases
the lock.  Then it signals on the state's associated condition, which is waited on by a sending
thread, and returns the states' associated message.

The implementation of fan-in channels is very similar to that of fan-out channels.

a one-to-one channel can also be in one of three possible states, but there is no associated
lock. Additional, none of the states are associated with queues.  Instead, there is a possible
state of a thread trying to send, with a condition and a message, or a possible state of a
thread trying to receive with a condition and an empty cell, or a possible inactive state.
The send operation checks if the channel's state is inactive and tries to use the
compareAndSwap operator to transactionally update the state of the channel to that of trying to
send.  If successful, it simply waits on sendCond, the condition that a receiving thread will
signal on, and then returns the unit value.  If the transactional update fails and the state is
that of a thread trying to receive on the channel, then it deposits the message in the state's
associated cell, updates the channel state to inactive, then signals on the state's associated
condition and returns the unit value.  If the communication analysis for the channel is
correctly one-to-one, then there should be no other thread trying update the state from the
state of a thread trying to receive, and no thread modifies that particular state, so no locks
are necessary.  Likewise, the send operation should never witness the state of another thread
already trying to send, if it is truly one-to-one.

The recv operation checks if the channel's state is inactive and tries to use the
compareAndSwap operator to transactionally update the state of the channel to that of trying
to receive.  If successful, it simply waits on recvCond, the condition that a sending thread
will signal on after it deposits a message, and then returns the deposited message.  If the
transactional update fails and the state is that of a thread trying to send on the channel,
then it updates the channel state to inactive, then signals on the state's associated
condition and returns the message associated with the sending thread.  If the communication
analysis for the channel is correctly one-to-one, then there should be no other thread trying
update the state from the state of a thread trying to send, and no thread modifies that
particular state, so no locks are necessary.  Likewise, the recv operation should never
witness the state of another thread already trying to receive, if it is truly one-to-one.


A one-shot channel consists of the same possible states as a one-to-one channel, but is
additionally associated with a mutex lock, to account for the fact that multiple threads may
try to receive on the channel, even though only at most one message is ever sent.

The send operation is like that of one-to-one channels, except that if the state is that of a
thread trying to receive, it simply deposits the message and signals on the associated
condition, without updating the channel's state to inactive, which would be unnecessary, since
no further attempts to send are expected.

The recv operation checks if the channel's state is inactive and tries to use the
compareAndSwap operator to transactionally update the state of the channel to that of trying
to receive.  If successful, it simply waits on recvCond, the condition that a sending thread
will signal on after it deposits a message, and then returns the deposited message.  If the
transactional update fails and the state is that of a thread trying to send on the channel,
then it acquires the lock, signals on the state's associated condition and returns the message
associated with the sending thread, without ever releasing the lock, so that competing
receiving threads will know to not progress.  If the state is that of a thread trying to
receive on the channel, the it acquires the lock, which should block the current thread
forever, if there truly is only one send ever.

An even more restrictive version of a channel with at most one send could be used if it's
determined that the number of receiving threads is at most one.  The one-shot-to-one channel is
composed of a possibly empty cell, a condition for a sending thread to wait on, and a condition
for a receiving thread to wait on.

The send operation deposits the message in the cell, signals on the recvCond, waits on the
sendCond, and then returns the unit value.  The recv operation waits on the recvCond, signals
on the sendCond and then returns the deposited message.

Although there are proofs that the communication topologies are sound with respect to the
semantics, it would additionally be important to have proofs that the above specialized
implementations are equivalent to the many-to-many implementation under the assumption of
particular communication topologies.


\section{Objectives}
If an algorithm for synchronization is specific to a maxiumum number of threads, it may be more
efficient than an algorithm that is generic for any number of threads.  For instance, if there
is only ever one thread sending and one thread receiving on a channel, then no locks are
needed, which saves time.  However, if there are multiple senders and multiple receivers, then
some form of locks or trials and aborts would be needed, which is costly.

The example implementations of generic synchronization and specialized syncrhonization suggest
that cost savings of specialized implementation are significant.  For example, if you know that
a channel has at most one sender and one receiver, then you will lower synchronization costs by
using an implemnetaiton that is specialized for one-to-one communication.  To be certain that
the new program with the specialized implementation behaves the same as the original program
with the generic implementaiton, you need to be certain of three basic properties: that the
specialized program behaves the same given one-to-one communication; that you have a procedure
to determine the oneo-to-one communication topology, and that the relation between the
procedure's input program and output topology upperbound is sound with respect to the semantics
of the program.  

Spending your energy to determine the topologies for each unique program and then verifying
them for each program would be exhausting. Instead, you would probably rather have a generic
procedure that can compute communication topologies for any program in a language, along with
a proof that the procedure is sound with respect to the programming language.

In this work I demonstostrate formal proofs that the a relation between programs and topologies
is sound with respect to the semantics of the programming language.  I refer to this as a
static relation, because the intent is that the topologies are computable from the programs,
although I do not formally prove computability in this work.  The static relation is defined
with a syntax directed structure, which gives strong evidence of computability.  Additionally,
I do not formally prove that the specialized implementations are behaviorally equivalent to a
generic implementation, but I suggest some plausible example implementations.

\section{Syntax Definitions}
The relations are defined over a simple language featuring a small subset of Concurrent ML
features. The features include recursive function abstraction with application, left and right
construction with pattern matching, pair construction with first and second projections, send
and receive event construction with synchronization, channel creation, thread spawning, and
unit literal.  The syntax and semantics are defined in a peculiar way to enable relations
between static and dynamic properties of the language.  A primititive construct is one that
contains references to names but cannot be evaulated any further. Send and receive events,
left and right constructs, pairs, and function abstractions are primitive constructs.

The syntax is in a very restrictive administrative normal form (ANF), in which every value or
evaluatable construct is bound to a name.  Furthermore, constructs only accept names for
eagerly evaluted inputs, rather than expression.  A control path is basically defined as a list
of bound names, where the names are in order of their respective constructs' evaluation. The
names are also annoted with information related to aspects of the control flow. 


The unit literal corresponds to a unit value. A dynamic channel value is uniquely identified by
the full control path up to the point of channel creation along with the name bound to the
channel creation construct. The value of a primitive construct is a closure over the construct
with an environment that maps the names to further values.

Bound expressions of the unit literal, primitive constructs, and first and second constructs
can be evalued to values in one step.  The seq step relation describes the evaluation of bound
expressions with environments to values.  The unit construct simply evaluates to the unit
value.  A prim construct is simply wrapped up with the environment.  The first projection is
evaluated to the abstract value of the first argument of the associated pair. The second
projection is evaluated to the abstract value of the second argument of the associated pair.

Other constructs for spawn, application, and case matching cannot be described with the seq
step because they do not evaluate to values in one step and require updating additional
information about the mode of the transition. 

\section{Dynamic Semantics Definitions}

The seq step up relation handles the evaluation of function application and case pattern
matching.  These bound expressions with associated environments are evalued to full expressions
along with a new environment.  Case matching is evaluated based on the case of the construct's
first argument.  If the first argument is a left case, then the case matching is evauluated to
the left expression along with an environment updated with a name specified for use in that
expression.  The value associated with the left case pattern is bound to the specified name in
the new environment. If the first argument is a right case, then then the case matching is
evaluated to the right expression along with an environment updated with a name specified for
use in that expression.  The value associated with the right case is bound to the specified
name in the new environment. Function application evaluates to the expression within the
applied function abstraction, along with the function abstraction's environment with a couple
of modifications.  The environment is updated with the recursive function name bound to the
function abstraction, and the parameter name is bound to the function argument specified in the
application expression. 


A continuation is composed of a name, an expression and an environment.  It represents an
expression and environment that should be evaluated once the name can be resolved to a value.
A state is composed of an expression, an evnironment, and a stack of continuations.
It represents information that might be evaluted to another state in the present of control
path information.  A trace pool associated control paths with states.  The associated control
path represent the path taken to reach the associated state. The leaf predicate desribes that a
path is has no descendants within a trace pool.  

The concur step relation describes the evaluation of a trace pool to another tracel pool.
Trace pools grow montonicially with respect to evaluation, retaining a full history.  A trace
pool is evaluated to a new trace pool based only on information associated with leaf paths and
their associated states.  If a leaf path is associated with a bound expresion that can be
evaluated to a value in one sequential step, then the trace pool is updated with the leaf path
extended by a label indicating a sequential transition, and the extended path is associated
with the let binding's next expression and the leaf path's associated environment updated with
the value bound to the let binding's name.  If the bound expression can be evaluated to an
expression and a new environment, then the leaf path is extended with a label indicating a
calling transition.  The extended path is associated with the the new expression and new
environment resulting from the evaluation of the bound expression, and the name and expression
of the let binding are pushed onto the stack to be evaluated in later steps.  If a leaf path is
associated with a result expression, then the trace pool is updated with the leaf path extended
with a label indicating a returning transition.  The new path is associated with a state
containing the expression popped from the continuation stack and the environment popped from
the stack and updated with continuation's name bound to the result's associated value.  If a
leaf path is associated with a channel creation construct, then the trace pool is updated with
the leaf path extended with a sequential transition, and its associated state contains the next
expression, and an environment updated with a new channel value.  If a leaf path is associated
with a let expression binding to a spawn contstruct, then the trace pool is updated with two
new paths extending the leaf path.  For one, the leaf path is extended with a sequential label
whose state has the next expression and the environment updated with the unit value bound to
the let binding name, and the original continuation stack. For the other, the leaf path
extended with a label indicating a spawning transition.  Its state has the spawned expression,
the original environment, and an empty continuation stack. 

If two leaves in the trace pool correspond to synchronization constructs on the same channel,
where one synchronizes on a send event and the other synchronizes on a receive event, then the
trace pool is updated with two new paths extending the two synchronizing leaf paths.  The leaf
path for the send event is extended by a label indicating sequential transition.  For its state
, the next expression of the let expression is used, and the environment is updated with the
unit value bound to the let expression name.  The leaf path for the receive event is also
extended by a label indicating sequential transition.  For its state, the next expression of
the let expression is used, and the environment is updated with the value associated with the
send event's second argument.   Additionally, the communication set is updated with the send
and receive paths, and the channel that is communicated on. 



\section{Static Semantics Definitions}

In order to determine communication topologies with some decent amount of precision, it is
necessary to determine values associated with expressions and names of a program.  In a
language that allows inifinite recursion, it is not always possible to determine the exact
values.  However, it's also not necessary.  Abstract values, which are imprecise approximations
of the values at runtime, are good enough.

abstract values consist of abstract unit, abstract channels, and abstract primitive values.
The abstract unit is actually no less precise than the actual unit value.  The abstract channel
is identified only by the name at which it is created, rather than the full control path that
leads up to it.  The abstract primitive value is simply a primitive construct without an
environment for looking up its named arguments. 

The static evaluation predicate is a relation from an input program to two outputs, each a map
of names to sets of abstract values.  A set of abstract values can be thought as a further
abstraction, allowing less precision. The first output represents a the values that might bind
to names.  The second output represents values that might be passed over channels.

The definition for static evaluation is nondeterministic, but its syntax-directed structure
suggests a refinement to computable definition, thus proving soundness with this definition
should be sufficient to prove soundness for the more practical computable definition.

For a result expression, there may be any abstract value bindings or communication. For all let
expressions, the bindings and communication are outputs for the next expression. For unit
binding, the binding name is bound to the abstract unit. For channel creation, the binding name
is bound to an abstract channel identified by the same binding name. For all primtive contruct
bindings, the binding name is bound to the abstract primtive value represented by the primitive
construct.  Additionaly for the primitive construct of function abstraction, the the recursive
parameter to the function abstraction is bound to the function abstraction, and the bindings
and communication are also outputs for the function abstraction's internal expression. For
spawn, the bindings and communication are also outputs for the spawned expression, and the the
binding name is bound to the abstract unit.

For synchronization, if the send event is bound to the syncrhonization argument, then the
binding name is bound to abstract unit, and the send event's channel communicates the argument
associated with the send event's message argument.  If the receive event is bound to the
synchronization argument, then the binding name is bound to the abstract value communicated by
the receive event's channel.

For the first projection, if its argument is a pair, then the binding name is bound to the
abastract value associated with the pair's first argument.  For the second projection, if its
argument is a pair, then the binding name is bound to the abstract value associated with the
pair's second argument.  

For the case matching, if its first argument is a left case, then the left name is bound to the
abstract value of the left case, the let binding name is bound to the result value of the left
expression, and the bindings and communication are outputs for the left expression.  If its
first argument is a right case, then the right name is bound to the abstract value of the right
case, the right binding name is ound to the result value of the right expression, and the
bindings and communication are outputs for the right expression. 

The static reachable predicate states that an expression can be reached from another
expression, by simply stating that an expression is reachable from itself,  and an expression
is reachable from an initial expression, if it is also reachable from the sub expressions of
the initial expression.  

for function application, if a function abstraction is bound to the first argument of
application, then the abstract value of the second argument of application (the function
argument) is bound to the abstraction's parameter name, and the resulting abstract value of the
abstraction is bound the the let binding name.

To describe communication statically, yet also somewhat precisely, it will be advantageous to
describe every expression in a with a short description.  There are two forms of expressions,
let binding expressions and result expressions.  A let binding expression is associated with a
label indicating its form and contains the name used for its first binding. A result
expression is associated with a label indicating its form and contains the name of the result's
argument.  The dynamic description also contains labels for representing the mode of
transition, which are slightly different due to the differences in how the static and dynamic
relations can be defined.  Since a goal of the static relations is that they imply a computable
refinement, there is an additional restriction to consider, resulting in the slightly different
labeling of transitions between expressions.    

the static send label predicate states that a label might represent a sycnronization to send on
a given abstract channel, in a given a program with given abstract value bindings.  The static
receive label predicate state that a label might represent a synchronization to receive on a
given abstract channel, in a given program with given abstract value bindings. 

\section{Static Communication Definitions}

The one shot predicate states that in a trace pool, there is only one control path that
synchronizes and sends on a given channel. Whether or not two attempts to synchronize on a
channel are competitive can be determined by
looking at the control paths of the trace pool. If two paths are ordered, that is, one is the
prefix of the other and vice versa, then the dynamic semantics states that they necessarily
occur in sequence, so the shorter path must synchronize before the longer path. Two paths may
be competitive only if they are unordered. The fan in predicate states that there is no
competition on the receiving end of a channel, by stating that any two paths that synchonize to
receive on a channel are ordered. The fan out predicate states that there is no competition on
the sending end of a channel, by stating that any two paths that syncronize to send on a
channel are ordered. The one to one predicates states that there is no competition on either
the receiving or the sending ends of a channel. 


-----low precision // no live channel analysis ----
Reppy and Xiao's work relies on detecting the liveness of channels in order to gain higher
precision in the communication analysis.  Since formal proofs are inherently complicated and
packed with details, I decided to simplify the problem, by developing formal proofs for
definitions without the extra complication of live analysis. However, I have purposely
structured the definitions to make adding live channel analysis to the definition and proofs
straight forward with just a few alterations to the definitions.  I will expand on these
alterations and outline a strategy that I belive will result formal proofs of soundness.  

Having formal proofs for the requirement that each reasoning step be clearly documented.
I define the static communicatin predicates relating programs to communnication topologies in
two different ways.  The first way is simpler but the second way allows more precise
communication topologies for many common programs.


-------------

For the simpler version, there are four kinds of control edges, indicating how one point in a
program transitions to another point in a program.  The modes of transition are sequencing,
calling, spawning, and returning. A transition is a triplet of a label, representing a point in
the progra, a control edge, and another label.  A step is just a label and a control edge,
without the destination label.  An abstract control path is a list of steps.  

the static traversable predicate states that a set of transitions describes all the transitions
that might be traversed for a program, given bindings of abstract values.  For a result
expression, any transition might be traversed.  For all let expressions, except those binding
to case matching and function application, the sequential transition from the top expression to
the sequenced expression might be traversable, and the traversable transitions are also the
traversable transitions for the sequenced expression.  For binding to function abstraction, the
traversable transitions are also traversable transitions for the inner expression of the
function abstraction.  For binding to spawning, the spawning transition from the top expression
to the spawned expression might be traversed, and the traversable transitions are also
traversable transitions for the spawned expression.

For binding to case matching, the the calling transition from the top expression to the left
case expression might be traversable, and the calling transition from the top expression to the
right case expression might be traversable.  The returning transition from the result of the
left case expression to the sequenced expression might be traversable, and the returning
transition from the result of the right case expression to the sequenced expression might be
traversable.  Additionally, the traversable transitions are traversable transitions the left
case expression, right case expression, and the sequenced expression.   

For binding to function application, if the applied name is acutally bound to a function
abstraction, then a calling transition from the top expression to the inner expression of the
abstraction might be traversable, and the returning transition from the result of the function
abstracted expression to the sequenced expression.  Additionally, the traversable transitions
are traversable transitions for the sequenced expression. 


The static traceable predicate states that an abstract control path can be traced according to
a set of transitions from a starting label to a final label matching a given condition.  An
empty path might be traceable if the start label is also the final label.  A path of one step
might be traceable if its label is the required start label, and there is a transition
containing the step and the transition's destination label meets the final label requirement.
For a path of two or more steps, the first label is the start label, there is a transition from
the first step to the second step, and the path from the second step onward also might be
traceable.

The static inclusive predicate states that two abstract paths represent might be traversed in
the same run of a program. Ordered paths might be inclusive, and also a path that diverges
from another at a spawn transition might be inclusive.  This concept is useful for achieving
greater precision, since if two paths cannot occur in the same run of a program, only one needs
to be counted towards the communication topology. 

The singular predicate states that two paths are the same or cannot occur in the same run of a
program. The noncompetitive predicates states that two paths are ordered or cannot occur in the
same run of a program. The static one shot predicate states that there is at most one attempt
to syncrhonize to send on an abstract channel in a run of a given program with given abstract
value bindings.

The static one to one predicate states that there is at most one thread attempting to send and
one thread attempting to receive on a given channel at any time during a run of a given
program.

The static fan out predicate states that there is at most one thread attempting to send on a
given channel at any time during a run of a given program. The static fan in predicate states
that there is at most one thread attempting to receive on a given channel at any time during a
run of a given program.



\section{Formal Reasoning}
The reasoning involved in proving each soundness theorem is based around breaking the
goal into simpler subgoals, and generalizing assumptions to create useful induction
hypotheses.  It is often useful to create helper definitions that can be deduced from premises
and enable general reasoning across arbitrary programs. A frequent pattern is to define
predicates in terms of semantic structures, like the environment, stack, and pool, and deduce 
the use of these predicates on the initial program state. 

Some parts of the generalized predicate definitions exist simply to prove that they imply uses
of the original expression predicate. However, the reason for the existence of the generalized
definitions is to allow direct access to properties that would otherwise be deeply nested in an
inductive structure and inaccessble for proofs.

One of the most difficult aspects of formal reasoning is in developing adequate definitions.
It is often possible to define a single semantics in multiple ways.
For instance, the sortedness of a list could be defined in terms of the sortedness of its tail
or in terms of the sortedness of its longest strict prefix.  To prove theorems relating
sortedness to other relations, it may be important that the other relations are inductively
defined on the same subpart of the list.  Some relations may only be definable on the tail,
while others are defineable on only the strict prefix.  In such cases, it would be necessary to
define sortedness in two ways, and prove their equivalence, in order to prove theorems relating
to less flexible relations.


The lemma for soundness of static one shot states that if an abstract channel is statically
classified as one shot for a given program, and value bindings derived from the program, then
any corresponding dynamic channel is classified as one shot over any trace pool that results
from running the program.  The lemma for static_fan_out_sound states that if an abstract
channel is statically classified as fan_out for a given program and an abstract environment
derived from that program, then any corresponding concrete channel is classified as fan_out
over any pool that results from running the program.  The lemmas for soundness of fan in, and
one to one follow similar patterns. 

The static predicates for communication topologies should be generalizations of procedures that
compute the topologies from programs.  The soundness of the static predicates must be provable
to be certain that statically described topologies are also observed when running the program.

-----
theorem static_one_shot_sound: 

∀ env_a convo_a e0 x_c pool convo path_c .
if
  static_eval env_a convo_a e0 and 
  static_one_shot env_a e0 x_c and 
  star concur_step [[] -> (Stt e0 [->] [])] {} pool convo
then
  one_shot pool (Ch path_c x_c)

-----
theorem static_fan_out_sound:
∀ env_a convo_a e0 x_c pool convo path_c. 
  if 
    static_eval env_a convo_a e0 and 
    static_fan_out env_a e0 x_c and 
    star concur_step [[] -> (Stt e0 [->] [])] {} pool convo
  then
    fan_out pool (Ch path_c x_c)" 

-----
theorem static_fan_in_sound:

∀ env_a convo_a e0 x_c pool convo path_c. 
  if
    static_eval env_a convo_a e0 and 
    static_fan_in env_a e0 x_c and 
    star concur_step [[] -> (Stt e [->] [])] {} pool convo
  then
    fan_in pool (Ch path_c x_c)

-----
theorem static_one_to_one_sound:

∀ env_a convo_a e0 x_c pool convo path_c. 
  if
    static_eval env_a, convo_a e0 and 
    static_one_to_one env_a e0 x_c and
    star concur_step [[] -> (Stt e0 [->] [])] {} pool convo
  then
    one_to_one pool (Ch path_c x_c)

-----

Theorem static_fan_out_sound is proved by a few simpler lemmas and the definitions
of static_fan_out and fan_out.  The three main lemmas are label_not_send_site_sound,
not_static_inclusive_sound, and not_static_traceable_sound.

Lemma not_static_traceable_sound states that if a running a programming traces a concrete
path, and a graph contains the statically traversable steps of the program, then there is an
abstract path corresponding to the traced concrete path is statically traceable.   

Lemma not_static_inclusive_sound states that if any two paths traced by running a programm
correspond two abstract paths that are statically inclusive.    

Lemma label_not_send_site_sound states that if a program is run to reach a synchronization on
a send event, then the label corresponding to the syncrhonization expression is statically
identified as a send site.


-----
lemma not_static_traceable_sound:

∀ e0 pool convo path x b e' env stack evn_a convo_a graph isEnd .
  if
    star concur_step ([[] -> (Stt e0 [->] [])], {}) (pool, convo) and 
    pool path = Some (Stt (Let x b e') env stack) and 
    static_eval env_a convo_a e0 and 
    static_traversable env_a graph e0 and 
    isEnd (NLet x)
  then
    ∃ path_a . 
      paths_correspond path path_a and 
      static_traceable graph (top_label e0) isEnd path_a

-----

lemma not_static_inclusive_sound:

∀ e0 pool convo path1 stt1 path2 stt2 path_a1 path_a2 . 
  if
    star concur_step [[] -> (Stt e0 [->] [])] {} pool convo
    pool path1 = Some stt1 and 
    pool path2 = Some stt2 and 
    paths_correspond path1 path_a1 and 
    paths_correspond path2 path_a2
  then
    static_inclusive path_a1 path_a2

-----

lemma label_not_send_site_sound:

∀ e0 pool convo path x x_e e' env stack x_sc x_m env' path_c x_c .
  if
    star concur_step [[] -> (Stt e0 [->] [])] {} pool convo and 
    pool path = Some (Stt (Let x (Sync x_e) e') env stack) and 
    env x_e = Some (VClsr (SendEvt x_sc x_m) env') and 
    env' x_sc = Some (VChn (Ch path_c x_c)) and 
    static_eval env_a convo_a e0
  then 
    static_send_label env_a e0 x_c (NLet x)

-----

Lemma not_static_traceable_sound is proved by generalizing static_traversable and static_eval
over pools, such that information about the a point in the program can be deduced by a fixed
number of steps regardless of where the location of the program point or the size of the
program.  Without such generalization, it would be possibe to prove soundness for a fixed
program, but not an arbitrary programs.

The generalization of static_traversable is captured in the predicates static_traversable_val,
static_traversable_env, static_traversable_stack, and static_traversable_pool.  The
generalization is designed to have two main features.  First, the static information that
describes one pool should also describe subsequent pools from running the program, as
information shifts from the expression to the environment, and stack.  Second, certain should
be described directly by a fixed number of logical steps, in constract to its representation in
the original predicate, which requires knowledge of features particular context in a program.
Most of the rules simply state that the nearest subexpression is statically traversable, and
static_traversable offers direct information about statically described steps in a program.
The exception is in the definition of static_traversable_stack, in the rule for a nonempty
stack, where there is the additional clause that the edge from a return point to the label of
the continuation expression exists in the graph.  This information is consistent with the
definition of static_traversable for expressions, but provides information about an edge in the
graph with a fixed number of logical steps, which would otherwise only be decucible by a
varying number of logical steps dependent on location of an expression in a program.



definition static_traversable_val of abstract_env -> transition_set -> val -> bool:

only

(∀ env_a graph . static_traversable_val env_a graph VUnt) and 

(∀ env_a graph c . static_traversable_val env_a graph (VChn c)) and

(∀ env_a graph env x_c x_m.
  if
    static_traversable_env env_a graph env 
  then 
    static_traversable_val env_a graph (VClsr (SendEvt x_c x_m) env)) and

(∀ env_a graph env x_c.
  if
    static_traversable_env env_a graph env 
  then
    static_traversable_val env_a graph (VClsr (RecvEvt x_c) env)) and

(∀ env_a graph env x_p .
  if
    static_traversable_env env_a graph env 
  then
    static_traversable_val env_a graph (VClsr (Lft x_p) env)) and

(∀ env_a graph env x_p .
  if
    static_traversable_env env_a graph env
  then
    static_traversable_val env_a graph (VClsr (Rght x_p) env)) and

(∀ env_a graph e_b env f x_p .
  if
    static_traversable env_a graph e_b and 
    static_traversable_env env_a graph env
  then
    static_traversable_val V F (VClsr (Abs f x_p e_b) env)) and

(∀ env_a graph env . 
  if
    static_traversable_env env_a graph env
  then
    static_traversable_val env_a graph (VClsr (Pair x1 x2) env))

-----

definition static_traversable_env of abstract_env -> transition_set -> env -> bool: 

only 

(∀ env_a graph env .
  if
    (∀ x v . if env x = Some v then static_traversable_val env_a graph v)
  then
    static_traversable_env env_a graph env) 


-----


definition static_traversable_stack of
  abstract_env -> transition_set -> var -> contin list -> bool:

only

(∀ env_a graph y . static_traversable_stack env_a graph y []) and

(∀ y e graph env_a graph env stack x env .
  if 
    {(NResult y, EReturn, top_label e)} ⊆ graph and
    static_traversable env_a graph e and
    static_traversable_env env_a graph env and
    static_traversable_stack env_a graph (rslt_var e) stack 
  then 
    static_traversable_stack env_a graph y ((Ctn x e env) # stack))


-----

definition static_traversable_pool of
  abstract_env -> transition_set -> trace_pool -> bool:

only

(∀ env_a graph pool .
  if
    (∀ path e env stack . if env path = Some (Stt e env stack) then 
      static_traversable env_a graph e and 
      static_traversable_env env_a graph env and 
      static_traversable_stack env_a graph (rslt_var e) stack) 
  then
      static_traversable_pool env_a graph pool)

-----

The abstract program transitions described by the various versions of static_traversable are
dependent on abstract value bindings (in the application case), which are described by the
static_eval predicate.  Thus generalized versions of static evaluation enables further
deduction of abstract program transitions.  As with the generalized versions of
static_traversable, the generalized versions of static_eval are designed to preserve abstract
value bindings across program execution steps, and also provide direct access to abstract
binding information in a fixed number of logical steps. 

definition static_eval_value of
  abstract_env -> abstract_convo -> val -> bool: 

only

(∀ env_a convo_a . static_eval_val env_a convo_a VUnit) and

(∀ env_a convo_a c . static_eval_val env_a convo_a (VChn c)) and

(∀ env_a convo_a env x_c x_m .
  if
    static_eval_env env_a convo_a env
  then
    static_eval_val env_a convo_a (VClsr (SendEvt x_c x_m) env)) and

(∀ env_a convo_a env x_c  .
  if
    static_eval_env env_a convo_a env
  then
    static_eval_val env_a convo_a (VClsr (RecvEvt x_c) env)) and

(∀ env_a convo_a env x_p  .
  if
    static_eval_env env_a convo_a env
  then
    static_eval_val env_a convo_a (VClsr (Lft x_p) env)) and

(∀ env_a convo_a env x_p  .
  if
    static_eval_env env_a convo_a env
  then
    static_eval_val env_a convo_a (VClsr (Rght x_p) env)) and


(∀ f x_p e_b env_a convo_a env .
  if
    {APrim (Abs f x_p e_b)} ⊆ env_a f and 
    static_eval env_a convo_a e_b and 
    static_eval_env env_a convo_a env
  then
    static_eval_val env_a convo_a (VClsr (Abs f x_p e_b) env)) and

(∀ env_a convo_a env x1 x2 .
  if
    static_eval_env env_a convo_a env
  then
    static_eval_val env_a convo_a (VClsr (Pair x1 x2) env))

----

definition static_eval_env of abstract_env -> abstract_env -> env -> bool:

only 

(∀ env_a convo_a env .
  if
    (∀ x v . if env x = Some v then
      {abstract v} ⊆ env_a x and
      static_eval_val env_a convo_a v)
  then 
    static_eval_env env_a convo_a env)


definition static_eval_stack of
  abstract_env -> abstract_env -> abstract_value set -> contin list -> bool:

only 

(∀ env_a convo_a res_a . static_eval_stack env_a convo_a res_a []) and

(∀ res_a env_a convo_a . 
  if 
    res_a ⊆ env_a x and
    static_eval env_a convo_a e and
    static_eval_env env_a convo_a env and
    static_eval_stack env_a convo_a env_a (rslt_var e) stack 
  then
    static_eval_stack env_a convo_a res_a ⇛ ((Ctn x e ρ) # stack))


definition static_eval_pool of abstract_env -> abstract_env -> trace_pool -> bool:

only
(∀ env_a convo_a pool .
  if
    (∀ path e env stack . if pool path = Some (Stt e env stack) then 
      static_eval env_a convo_a e and
      static_eval_env env_a convo_a env and
      static_eval_stack env_a convo_a env_a (rslt_var e) stack)
  then 
    static_eval_pool env_a convo_a pool)

Lemma not_static_traceable_sound follows from the generalized lemma
not_static_traceable_pool_sound, which contains the generalized premise of
static_traversable_pool. The generalized lemma follows from lemma
static_traversable_pool_preserved_star, the predicate star_left and its equivalence to star,
and induction on star_left. The lemma also relies on the definition of static_traversable_pool
and lemma static_traversable_pool_preserved to deduce abstract transition information about the
pool containing the traced path.

definition star_left of ('a -> 'a -> bool) -> 'a -> 'a -> bool:
only
(∀ r z z . star_left r z z) and
(∀ r x y z .
  if
    star_left R x y and R y z
  then
    star_left R x z)


lemma not_static_traceable_pool_sound:
∀ e0 pool convo path x b e' env stack evn_a convo_a graph isEnd .
  if
    star concur_step ([[] -> (Stt e0 [->] [])], {}) (pool, convo) and 
    pool path = Some (Stt (Let x b e') env stack) and 
    static_eval env_a convo_a e0 and 
    static_traversable env_a graph pool and 
    isEnd (NLet x)
  then
    ∃ path_a . 
      paths_correspond path path_a and 
      static_traceable graph (top_label e0) isEnd path_a

lemma static_traversable_pool_preserved_star:
∀  pool convo pool' convo' env_a convo_a graph .
  if
    star concur_step pool convo pool' convo' and 
    static_eval_pool env_a convo_a pool and
    static_traversable_pool env_a graph pool
  then
    static_traversable_pool env_a graph pool' 


Lemma static_traversable_pool_preserved follows from lemma not_static_bound_sound_pool, due to
its information about abstract bindings.  That lemma, in turn, relies on static_eval_pool
preserved, which follows from induction on star concur_step.

lemma not_static_bound_sound_pool:
∀ pool convo pool' convo' env_a convo_a path' e' env' stack' x v .
  if
    star concur_step pool convo pool' convo' and 
    static_eval_pool env_a convo_a pool and 
    pool' path' = Some (Stt e' env' stack') and 
    env' x = Some v 
  then
    {abstract v} ⊆ env_a x


lemma static_eval_pool_preserved:
∀ pool convo pool' convo' env_a convo_a .
  if
    star concur_step pool convo pool' convo' 
    static_eval_pool env_a convo_a pool
  then
    static_eval_pool env_a convo_a pool'


-------------------------------------------------------------
static communication B ...
-------------------------------------------------------------
I have developed a number of definitions that will most likely be crucial to proving soundness
of a higher precision static analysis.  The proofs are not yet complete, however it may be
instructive to outline the conjectures that rely on these definition and the strategy of
breaking the proof into subgoals that rely on these definitions.


The higher precision defintions for static communication topologies enables the discrimination
between channels created by the same piece of code, but at different instances during a run of
a program.  For example, a function abstraction may specify the creation of a channel with a
binding to the name x.  This function may be called twice during a run of the program,
resulting in two distinct channels.  However, the abstract channels would be indentified by the
same name x.  To get around this issue, the static communications definitions are complicated
to ignore expresions that apply the function abstraction containing the channel creation of
interest.  Doing so requires describing a trimmed down sub program for each channel of
interest.  To avoid disconnecting the channel creation portion of the program from
communicating threads defined outside the channel's function abstraction, the trimmed program
is expressed in terms of transitions, with sending transitions used to connect communication
points. Thus, the modes of transition are sequential, spawning, calling, returining, and
sending. 


The static traversable predicate differs from the simpler version in a few ways.  First, the
predicate is dependent on the higher order predicate for stating tat a label might represent a
receive site.  Second, in the case of a let binding to synchronization to send, a sending
transition from let binding name to a receiving expression.






\section{Mathematical Artifacts}

\begin{lstlisting}[language=ML, style=codestyle1]
  type thread_id
  val spawn : (unit -> unit) -> thread_id

  type 'a chan
  val channel : unit -> 'a chan
  val recv : 'a chan -> 'a
  val send : ('a chan * 'a) -> unit
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]

  signature SERV = sig 
    type serv
    val make : unit -> serv
    val call : serv * int -> int
  end

  structure Serv : SERV = struct 
    datatype serv = S of (int * int chan) chan 

    fun make () = let 
      val reqChn = channel ()
      fun loop state = let
        val (v, replCh) = recv reqChn in 
        send (replCh, state);
        loop v end in
      spawn (fn () => loop 0);
      S reqChn end 

    fun call (server, v) = let 
      val S reqChn = server
      val replChn = channel () in 
      send (reqCh, (v, replCh));
      recv replChn end end

  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]

  type 'a event
  val sync : 'a event -> 'a
  val recvEvt : 'a chan -> 'a event
  val sendEvt : 'a chan * 'a -> unit event
  val choose : 'a event * 'a event -> 'a event

  fun send (ch, v) = sync (sendEvt (ch, v))
  fun recv v = sync (recvEvt v)

  val thenEvt : 'a event * ('a -> 'b event) -> 'b event

  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  val server = Serv.make ()
  val _ = spawn (fn () => Serv.call (server, 35))
  val _ = spawn (fn () => 
    Serv.call (server, 12); 
    Serv.call (server, 13))
  val _ = spawn (fn () => Serv.call (server, 81))
  val _ = spawn (fn () => Serv.call (server, 44))
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  structure Serv : SERV = struct 
    datatype serv = S of (int * int chan) chan 

    fun make () = let 

      val reqChn = FanIn.channel()

      fun loop state = let
        val (v, replCh) = FanIn.recv reqChn in 
        OneShot.send (replCh, state);
        loop v end in

      spawn (fn () => loop 0);
      S reqChn end 

    fun call (server, v) = let 
      val S reqChn = server
      val replChn = OneShot.channel () in 
      FanIn.send (reqCh, (v, replCh));
      OneShot.recv replChn end

    end
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  let
    val w = 4
    val x = ref 1
    val y = ref 2
    val z = (!x + 1) + (!y + 2) + (w - 3)
    val w = 1 in
    y := 0;
    (!y + 2) - (!x + 1) * (w - 3) end
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  let 
    val x = 1  
    val y = 2
    val z = ref (4 * 73)
    val x = 4 in 
    z := 1; 
    x * !z end
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]

  let 
    val f = fn x => x 1
    val g = fn y => y + 2
    val h = fn z => z + 3 in 
    (f g) + (f h) end

\end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  datatype 'a list = Nil | Cons 'a ('a list)

  inductive
    sorted ::
      ('a %$\Rightarrow$% 'a %$\Rightarrow$% bool) %$\Rightarrow$%
      'a list %$\Rightarrow$% bool where
    Nil : sorted P Nil |
    Single : sorted P (Cons x Nil) |
    Cons :
      P x y %$\Longrightarrow$%
      sorted P (Cons y ys) %$\Longrightarrow$%
      sorted P (Cons x (Cons y ys))
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  datatype nat = Z | S nat 

  inductive
    lte ::
      nat %$\Rightarrow$% nat %$\Rightarrow$% bool where
    Eq : lte n n |
    Lt : lte n1 n2 %$\Longrightarrow$% lte n1 (S n2)

  theorem "
    sorted lte
      (Cons (Z) (Cons (S Z)
        (Cons (S Z) (Cons
          (S (S (S Z))) Nil))))"
    apply (rule Cons)
    apply (rule Lt)
    apply (rule Eq)
    apply (rule Cons)
    apply (rule Eq)
    apply (rule Cons)
    apply (rule Lt)
    apply (rule Lt)
    apply (rule Eq)
    apply (rule Single)
    done
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  definition True :: bool where 
    True %$\equiv$% ((%$\lambda$%x ::bool. x) = (%$\lambda$%x. x))

  definition False :: bool where 
    False %$\equiv$% (%$\forall$%P. P)

  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  signature CHAN = sig
    type 'a chan 
    val channel : unit -> 'a chan
    val send : 'a chan * 'a -> unit
    val recv : 'a chan -> 'a
    end     
\end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]

  structure ManyToManyChan : CHAN = struct
    type message_queue = 'a option ref queue

    datatype 'a chan_content = 
      Send of (condition * 'a) queue | 
      Recv of (condition * 'a option ref) queue | 
      Inac

    datatype 'a chan =
      Chn of 'a chan_content ref * mutex_lock 

    fun channel () = Chn (ref Inac, mutexLock ())

    fun send (Chn (conRef, lock)) m = 
      acquire lock;
      (case !conRef of
        Recv q => let
          val (recvCond, mopRef) = dequeue q in
          mopRef := Some m;
          if (isEmpty q) then conRef := Inac else (); 
          release lock; signal recvCond; () end |
        Send q => let
          val sendCond = condition () in
          enqueue (q, (sendCond, m));
          release lock; wait sendCond; () end |
        Inac => let
          val sendCond = condition () in
          conRef := Send (queue [(sendCond, m)]);
          release lock; wait sendCond; () end)

    fun recv (Chn (conRef, lock)) =  
      acquire lock;
      (case !conRef of 
        Send q => let
          val (sendCond, m) = dequeue q in
          if (isEmpty q) then
            conRef := Inac
          else
            (); 
          release lock; signal sendCond; m end |
        Recv q => let
          val recvCond = condition ()
          val mopRef = ref None in
          enqueue (q, (recvCond, mopRef));
          release lock; wait recvCond;
          valOf (!mopRef) end |
        Inac => let
          val recvCond = condition ()
          val mopRef = ref None in
          conRef := Recv (queue [(recvCond, mopRef)]);
          release lock; wait recvCond;
          valOf (!mopRef) end)

    end

  \end{lstlisting}

  \begin{lstlisting}[language=ML, style=codestyle1]

    structure FanOutChan : CHAN = struct

    datatype 'a chan_content =
      Send of condition * 'a |
      Recv of (condition * 'a option ref) queue  |
      Inac

    datatype 'a chan =
      Chn of 'a chan_content ref * mutex_lock

    fun channel () = Chn (ref Inac, mutexLock ())

    fun send (Chn (conRef, lock)) m = let
      val sendCond = condition () in
      case cas (conRef, Inac, Send (sendCond, m)) of
        Inac => (* conRef already set *)
          wait sendCond; () |
        Recv q => 
        (* the current thread is
          * the only one that updates from this state *)
          acquire lock;
          (let
            val (recvCond, mopRef) = dequeue q in
            mopRef := Some m; 
            if (isEmpty q) then conRef := Inac else (); 
            release lock; signal (recvCond);
            () end) |
        Send _ => raise NeverHappens end

    fun recv (Chn (conRef, lock)) =
      acquire lock;
      (case !conRef of
        Inac => let
          val recvCond = condition ()
          val mopRef = ref None in
          conRef := Recv (queue [(recvCond, mopRef)]);
          release lock; wait recvCond;
          valOf (!mopRef) end |
        Recv q => let
          val recvCond = condition () 
          val mopRef = ref None in
          enqueue (q, (recvCond, mopRef));
          release lock; wait recvCond;
          valOf (!mopRef) end |
        Send (sendCond, m) =>
          conRef := Inac;
          release lock;
          signal sendCond;
          m end) 

    end 
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  structure FanInChan : CHAN = struct

  datatype 'a chan_content =
    Send of (condition * 'a) queue |
    Recv of condition * 'a option ref |
    Inac

  datatype 'a chan =
    Chn of 'a chan_content ref * mutex_lock

  fun channel () = Chn (ref Inac, mutexLock ())

  fun send (Chn (conRef, lock)) m = 
    acquire lock;
    case !conRef of
    Recv (recvCond, mopRef) => 
      mopRef := Some m; conRef := Inac;
      release lock; signal recvCond;
      () |
    Send q => let
      val sendCond = condition () in
      enqueue (q, (sendCond, m));
      release lock; wait sendCond;
      () end |
    Inac => let
      val sendCond = condition () in
      conRef := Send (queue [(sendCond, m)])
      release lock; wait sendCond; () end 

  fun recv (Chn (conRef, lock)) = let
    val recvCond = condition () 
    val mopRef = ref None in
    case cas (conRef, Inac, Recv (recvCond, mopRef)) of
      Inac => (* conRef already set *)
        wait recvCond; valOf (!mopRef) |
      Send q =>
        (* the current thread is the only one
        -* that updates the state from this state *)
        acquire lock;
        (let
          val (sendCond, m) = dequeue q in
          if (isEmpty q) then conRef := Inac else (); 
          release lock; signal sendCond; m end) |
      Recv _ => raise NeverHappens end end

  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]

structure OneToOneChan : CHAN = struct

  datatype 'a chan_content =
    Send of condition * 'a |
    Recv of condition * 'a option ref |
    Inac  

  datatype 'a chan = Chn of 'a chan_content ref

  fun channel () = Chn (ref Inac)

  fun send (Chn conRef) m = let
    val sendCond = condition () in
    case cas (conRef, Inac, Send (sendCond, m)) of
      Inac => 
        (* conRef already set to Send *)
        wait sendCond; () |
      Recv (recvCond, mopRef) =>
        (* the current thread is the only one
        -* that accesses conRef for this state *)
        mopRef := Some m; conRef := Inac;
        signal recvCond; () |
      Send _ => raise NeverHappens end end


  fun recv (Chn conRef) = let
    val recvCond = condition ();
    val mopRef = ref None in
    case cas (conRef, Inac, Recv (recvCond, mopRef)) of
      Inac => (* conRef already set to Recv*)
        wait recvCond; valOf (!mopRef) |
      Send (sendCond, m) =>
        (* the current thread is the only one
        -* that accesses conRef for this state *)
        conRef := Inac; signal sendCond; m |
      Recv _ => raise NeverHappens end end 

  end
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  structure OneShotChan : CHAN = struct

  datatype 'a chan_content =
    Send of condition * 'a |
    Recv of condition * 'a option ref |
    Inac  

  datatype 'a chan = Chn of 'a chan_content ref * mutex_lock

  fun channel () = Chn (ref Inac, lock ())

  fun send (Chn (conRef, lock)) m = let
    val sendCond = condition () in
    case (conRef, Inac, Send (sendCond, m)) of
      Inac =>
        (* conRef already set to Send*)
        wait sendCond; () |
      Recv (recvCond, mopRef) =>
        mopRef := Some m; signal recvCond;
        () |
      Send _ => raise NeverHappens end end


  fun recv (Chn (conRef, lock)) = let
    val recvCond = condition ()
    val mopRef = ref None in
    case (conRef, Inac, Recv (recvCond, mopRef)) of
      Inac =>
        (* conRef already set to Recv*)
        wait recvCond; valOf (!mopRef) |
      Send (sendCond, m) =>
        acquire lock; signal sendCond;
        (* never relases lock;
        -* blocks others forever *)
        m |
      Recv _ =>
        acquire lock;
        (* never able to acquire lock;
        -* blocked forever *)
        raise NeverHappens end end

  end
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
structure OneShotToOneChan : CHAN = struct

  datatype 'a chan =
    Chn of condition * condition * 'a option ref

  fun channel () =
    Chn (condition (), condition (), ref None)

  fun send (Chn (sendCond, recvCond, mopRef)) m =
    mopRef := Some m; signal recvCond;  
    wait sendCond; ()

  fun recv (Chn (sendCond, recvCond, mopRef)) =
    wait recvCond; signal sendCond;
    valOf (!mopRef)

  end
  \end{lstlisting}


\section{Syntax}

\begin{lstlisting}[style=codestyle1]

  datatype var = Var string

  datatype exp = 
    Let var boundexp exp |
    Rslt var

  boundexp =
    Unt |
    MkChn |
    Prim prim |
    Spwn exp |
    Sync var |
    Fst var |
    Snd var |
    Case var var exp var exp |
    App var var and

  prim = 
    SendEvt var var |
    RecvEvt var |
    Pair var var |
    Lft var |
    Rht var |
    Abs var var ex

\end{lstlisting}



\section{Dynamic Semantics}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  datatype ctrl_label = 
    LNxt var | LSpwn var | LCall var | LRtn var

  type_synonym ctrl_path = (ctrl_label list)

  datatype chan = Chn ctrl_path var

  datatype val = 
    VUnt | VChn chan | VClsr prim (var %$\rightharpoonup$% val)

  datatype ctn = Ctn var exp (var %$\rightharpoonup$% val)  

  datatype state = Stt exp (var %$\rightharpoonup$% val) (ctn list) 

  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive
    seq_step ::
      bind * (var %$\rightharpoonup$% val)) %$\Rightarrow$% val %$\Rightarrow$% bool where
    LetUnt : 
      seq_step (Unt, env) VUnt |
    LetPrim :
      seq_step (Prim p, env) (VClsr p env) |
    LetFst :
      env xp = Some (VClsr (Pair x1 x2) envp) %$\Longrightarrow$%
      envp x1 = Some v %$\Longrightarrow$% 
      seq_step (Fst xp, env) v |
    LetSnd : 
      env xp = Some (VClsr (Pair x1 x2) envp) %$\Longrightarrow$%  
      envp x2 = Some v %$\Longrightarrow$% 
      seq_step (Snd xp, env) v


  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]


  inductive
    seq_step_up ::
      bind * (var %$\rightharpoonup$% val)) %$\Rightarrow$%
      exp * val_env %$\Rightarrow$% bool where 
    LetCaseLft :
      env xs = Some (VClsr (Lft xl') envl) %$\Longrightarrow$%
      envl xl' = Some vl %$\Longrightarrow$%
      seq_step_up
        (Case xs xl el xr er, env)
        (el, env(xl %$\mapsto$% vl)) |
    LetCaseRht : 
      env xs = Some (VClsr (Rht xr') envr) %$\Longrightarrow$% 
      envr xr' = Some vr %$\Longrightarrow$%
      seq_step_up
        (Case xs xl el xr er, env)
        (er, env(xr %$\mapsto$% vr)) |
    LetApp :
      env f = Some (VClsr (Abs fp xp el) envl) %$\Longrightarrow$% 
      env xa = Some va  %$\Longrightarrow$% 
      seq_step_up
        (App f xa, env)
        (el, envl(
          fp %$\mapsto$% (VClsr (Abs fp xp el) envl),
          xp %$\mapsto$% va))

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]


  type_synonym cmmn_set = (ctrl_path * chan * ctrl_path) set

  type_synonym trace_pool = ctrl_path %$\rightharpoonup$% state

  inductive
    leaf ::
      trace_pool %$\Rightarrow$% ctrl_path %$\Rightarrow$% bool where
    intro :
      trpl pi %$\neq$% None %$\Longrightarrow$% 
      (%$\nexists$% pi' . trpl pi' %$\neq$% None %$\land$% strict_prefix pi pi') %$\Longrightarrow$%  
      leaf trpl pi

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive
    concur_step ::
      trace_pool * cmmn_set %$\Rightarrow$%
      trace_pool * cmmn_set %$\Rightarrow$%
      bool where 
    Seq_Sttep_Down :
      leaf trpl pi %$\Longrightarrow$%
      trpl pi = Some
        (Stt (Rslt x) env
          ((Ctn xk ek envk) # k)) %$\Longrightarrow$%
      env x = Some v %$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(pi @ [LRtn xk] %$\mapsto$%
          (Stt ek (envk(xk %$\mapsto$% v)) k)), ys) |
    Seq_Step :
      leaf trpl pi %$\Longrightarrow$%
      trpl pi = Some
        (Stt (Let x  b e) env k) %$\Longrightarrow$%
      seq_step (b, env) v%$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(pi @ [LNxt x] %$\mapsto$%
          (Stt e (env(x %$\mapsto$% v)) k), ys) |
    Seq_Step_Up : 
      leaf trpl pi %$\Longrightarrow$%
      trpl pi = Some
        (Stt (Let x b e) env k) %$\Longrightarrow$%
      seq_step_up (b, env) (e', env') %$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(pi @ [LCall x] %$\mapsto$%
          (Stt e' env'
            ((Ctn x e env) # k))), ys) |
    LetMkCh : 
      leaf trpl pi %$\Longrightarrow$%
      trpl pi = Some (Stt (Let x MkChn e) env k) %$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(pi @ [LNxt x] %$\mapsto$%
          (Stt e (env(x %$\mapsto$% (VChn (Chn pi x)))) k)), ys) |
    LetSpwn :
      leaf trpl pi %$\Longrightarrow$%
      trpl pi = Some
        (Stt (Let x (Spwn ec) e) env k) %$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(
          pi @ [LNxt x] %$\mapsto$%
              (St e (env(x %$\mapsto$% VUnt)) k), 
          pi @ [LSpwn x] %$\mapsto$%
              (St ec env []), ys) |
    LetSync :
      leaf trpl pis %$\Longrightarrow$%
      trpl pis = Some
        (Stt (Let xs (Sync xse) es) envs ks) %$\Longrightarrow$%
      envs xse = Some
        (VClsr (SendEvt xsc xm) envse) %$\Longrightarrow$%
      leaf trpl pir  %$\Longrightarrow$%
      trpl pir = Some
        (Stt (Let xr (Sync xre) er) envr kr) %$\Longrightarrow$%
      envr xre = Some
        (VClsr (RecvEvt xrc) envre) %$\Longrightarrow$%
      envse xsc = Some (VChn c) %$\Longrightarrow$%
      envre xrc = Some (VChn c) %$\Longrightarrow$%
      envse xm = Some vm %$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(
          pis @ [LNxt xs] %$\mapsto$%
            (Stt es (envs(xs %$\mapsto$% VUnt)) ks), 
          pir @ [LNxt xr] %$\mapsto$%
            (Stt er (envr(xr %$\mapsto$% vm)) kr)), 
          ys %$\cup$% {(pis, c, pir)})

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive
    star ::
      ('a %$\Rightarrow$% 'a %$\Rightarrow$% bool) %$\Rightarrow$%
      'a %$\Rightarrow$% 'a %$\Rightarrow$% bool for r where
    refl : star r x x |
    step : r x y %$\Longrightarrow$% star r y z %$\Longrightarrow$% star r x z
  \end{lstlisting}



\section{Dynamic Communication}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive
    is_send_path ::
      trace_pool %$\Rightarrow$% chan %$\Rightarrow$%
      control_path %$\Rightarrow$% bool where
    intro :
      trpl piy = Some
        (Stt (Let xy (Sync xe) en) env k) %$\Longrightarrow$%
      env xe = Some
        (VClsr (SendEvt xsc xm) enve) %$\Longrightarrow$%
      enve xsc = Some (VChn c) %$\Longrightarrow$%
      is_send_path trpl c piy

  inductive
    is_recv_path ::
      trace_pool %$\Rightarrow$% chan %$\Rightarrow$%
      control_path %$\Rightarrow$% bool where
    intro :
      trpl piy = Some
        (Stt (Let xy (Sync xe) en) env k) %$\Longrightarrow$%
      env xe = Some
        (VClsr (RecvEvt xrc) enve) %$\Longrightarrow$%
      enve xrc = Some (VChn c) %$\Longrightarrow$%
      is_recv_path trpl c piy

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive
    every_two ::
      ('a %$\Rightarrow$% bool) %$\Rightarrow$%
      ('a %$\Rightarrow$% 'a %$\Rightarrow$% bool) %$\Rightarrow$% bool where
    intro : (%$\forall$% pi1 pi2 .
        p x1 %$\longrightarrow$%
        p x2 %$\longrightarrow$%
        r x1 x2) %$\Longrightarrow$%
      every_two p r

  inductive
    ordered ::
      'a list %$\Rightarrow$% 'a list %$\Rightarrow$% bool where
    left : prefix pi1 pi2 %$\Longrightarrow$% ordered pi1 pi2 |
    right : prefix pi2 pi1 %$\Longrightarrow$% ordered pi1 pi2

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive one_shot :: trace_pool %$\Rightarrow$% chan %$\Rightarrow$% bool where
    intro :
      every_two
        (is_send_path trpl c) op= %$\Longrightarrow$% 
      one_shot trpl c

  inductive fan_out :: trace_pool %$\Rightarrow$% chan %$\Rightarrow$% bool where
    intro :
      every_two
        (is_send_path trpl c) ordered %$\Longrightarrow$%
      fan_out trpl c

  inductive fan_in :: trace_pool %$\Rightarrow$% chan %$\Rightarrow$% bool where
    intro :
      every_two
        (is_recv_path trpl c) ordered %$\Longrightarrow$% 
      fan_in trpl c

  inductive one_to_one :: trace_pool %$\Rightarrow$% chan %$\Rightarrow$% bool where
    intro :
      fan_out trpl c %$\Longrightarrow$%
      fan_in trpl c %$\Longrightarrow$% 
      one_to_one trpl c

  \end{lstlisting}


\section{Static Semantics}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  datatype abstract_value =
    AChn var |
    AUnt |
    APrim prim

  type_synonym abstract_env = var %$\Rightarrow$% abstract_value set

  fun rslt_var :: exp %$\Rightarrow$% var where
    rslt_var (Rslt x) = x |
    rslt_var (Let _ _ e) = (rslt_var e)

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]


  inductive
    static_eval_exp ::
      abstract_env * abstract_env %$\Rightarrow$%
      exp %$\Rightarrow$% bool where
    Rslt :
      static_eval_exp (V, C) (Rslt x) |
    let_unt :
      {AUnt} %$\subseteq$% V x %$\Longrightarrow$%
      static_eval_exp (V, C) e %$\Longrightarrow$% 
      static_eval_exp (V, C) (Let x Unt e) |
    let_chan : 
      {AChn x} %$\subseteq$% V x  %$\Longrightarrow$%
      static_eval_exp (V, C) e %$\Longrightarrow$%
      static_eval_exp (V, C) (Let x (MkChn) e) |
    let_send_evt : 
      {APrim (SendEvt xc xm)} %$\subseteq$% V x %$\Longrightarrow$%
      static_eval_exp (V, C) e %$\Longrightarrow$% 
      static_eval_exp (V, C)
        (Let x (Prim (SendEvt xc xm)) e) |
    let_recv_evt :
      {APrim (RecvEvt xc)} %$\subseteq$% V x %$\Longrightarrow$%
      static_eval_exp (V, C) e %$\Longrightarrow$% 
      static_eval_exp (V, C)
        (Let x (Prim (RecvEvt xc)) e) |
    let_pair : 
      {APrim (Pair x1 x2)} %$\subseteq$% V x %$\Longrightarrow$%
      static_eval_exp (V, C) e %$\Longrightarrow$% 
      static_eval_exp (V, C) (Let x (Pair x1 x2) e) |
    let_left : 
      {APrim (Left xp)} %$\subseteq$% V x %$\Longrightarrow$%
      static_eval_exp (V, C) e %$\Longrightarrow$% 
      static_eval_exp (V, C) (Let x (Left xp) e) |
    let_right :
      {APrim (Right xp)} %$\subseteq$% V x %$\Longrightarrow$%
      static_eval_exp (V, C) e %$\Longrightarrow$% 
      static_eval_exp (V, C) (Let x (Right xp) e) |
    let_abs : 
      {APrim (Abs f' x' e')} %$\subseteq$% V f' %$\Longrightarrow$%
      static_eval_exp (V, C) e' %$\Longrightarrow$%
      {APrim (Abs f' x' e')} %$\subseteq$% V x %$\Longrightarrow$%
      static_eval_exp (V, C) e %$\Longrightarrow$% 
      static_eval_exp (V, C) (Let x (Abs f' x' e') e) |
    let_spawn :
      {AUnt} %$\subseteq$% V x %$\Longrightarrow$%
      static_eval_exp (V, C) ec %$\Longrightarrow$% 
      static_eval_exp (V, C) e %$\Longrightarrow$%  
      static_eval_exp (V, C) (Let x (Spwn ec) e) |
    let_sync  : 
      %$\forall$% xsc xm xc . 
        (APrim (SendEvt xsc xm)) %$\in$% V xe %$\longrightarrow$% 
        AChn xc %$\in$% V xsc %$\longrightarrow$%
        {AUnt} %$\subseteq$% V x %$\land$% V xm %$\subseteq$% C xc %$\Longrightarrow$%
      %$\forall$% xrc xc . 
        (APrim (RecvEvt xrc)) %$\in$% V xe %$\longrightarrow$%
        AChn xc %$\in$% V xrc %$\longrightarrow$%
        C xc %$\subseteq$% V x %$\Longrightarrow$%
      static_eval_exp (V, C) e %$\Longrightarrow$%  
      static_eval_exp (V, C) (Let x (Syync xe) e) |
    let_fst : 
      %$\forall$% x1 x2.
        (APrim (Pair x1 x2)) %$\in$% V xp %$\longrightarrow$%
        V x1 %$\subseteq$% V x %$\Longrightarrow$% 
      static_eval_exp (V, C) e %$\Longrightarrow$% 
      static_eval_exp (V, C) (Let x (Fst xp) e) |
    let_snd : 
    %$\forall$% x1 x2 .
      (APrim (Pair x1 x2) %$\in$% V xp %$\longrightarrow$%
      V x2 %$\subseteq$% V x %$\Longrightarrow$% 
    static_eval_exp (V, C) e %$\Longrightarrow$% 
    static_eval_exp (V, C) (Let x (Snd xp) e) |
  let_case :
    %$\forall$% xl' .
      (APrim (Left xl')) %$\in$% V xs %$\longrightarrow$%
        V xl' %$\subseteq$% V xl %$\land$% V (rslt_var el) %$\subseteq$% V x %$\land$%
        static_eval_exp (V, C) el %$\Longrightarrow$%
    %$\forall$% xr' .
      (APrim (Right xr')) %$\in$% V xs %$\longrightarrow$%
        V xr' %$\subseteq$% V xr %$\land$% V (rslt_var er) %$\subseteq$% V x %$\land$%
        static_eval_exp (V, C) er %$\Longrightarrow$%
        static_eval_exp (V, C) e %$\Longrightarrow$% 
      static_eval_exp (V, C) (Let x (Case xs xl el xr er) e) |
  let_app :
    %$\forall$% f' x' e' .
      (APrim (Abs f' x' e') %$\in$% V f %$\longrightarrow$%
      V xa %$\subseteq$% V x' %$\land$%
      V (rslt_var e') %$\subseteq$% V x %$\Longrightarrow$% 
    static_eval_exp (V, C) e %$\Longrightarrow$% 
    static_eval_exp (V, C) (Let x (App f xa) e)

  \end{lstlisting}



\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive static_reachable :: exp %$\Rightarrow$% exp %$\Rightarrow$% bool where
    Refl :
      static_reachable e e | 
    let_Spawn_Child
      static_reachable ec e %$\Longrightarrow$%
      static_reachable (Let x (Spwn ec) en) e |
    let_Case_Left :
      static_reachable el e %$\Longrightarrow$%
      static_reachable (Let x (case xs xl el xr er) en) e |
    let_Case_Right :
      static_reachable er e %$\Longrightarrow$%
      static_reachable (Let x (case xs xl el xr er) en) e |
    let_Abs_Body : "
      static_reachable eb e %$\Longrightarrow$%
      static_reachable (Let x (Abs f xp eb) en) e | 
    Let :
      static_reachable en e %$\Longrightarrow$%
      static_reachable (Let x b en) e
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]


  fun abstract :: val %$\Rightarrow$% abstract_value where
    abstract VUnt = AUnt |
    abstract VChn (Chn pi x) = AChn x |
    abstract VClsr p env = APrim p

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
locale semantics_sound =
  assumes
    exp_always_not_static_bound_sound :
      env' x = Some v %$\Longrightarrow$%
      (V, C) static_eval e %$\Longrightarrow$%
      ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])], H) star concur_step (trpl', H') %$\Longrightarrow$%
      trpl' pi = Some (Stt e' env' k') %$\Longrightarrow$%
      {|v|} %$\subseteq$% V x and

    exp_always_exp_not_static_reachable_sound: 
      ([[] %$\mapsto$% (Stt e0 (%$\lambda$% _ . None) [])], {}) star concur_step (trpl', H') %$\Longrightarrow$%
      trpl' pi' = Some (Stt e' env' k') %$\Longrightarrow$%
      static_reachable e0 e'
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive 
    static_eval_val ::
      abstract_env * abstract_env %$\Rightarrow$% val %$\Rightarrow$% bool and  
    static_eval_env ::
      abstract_env * abstract_env %$\Rightarrow$% val_env %$\Rightarrow$% bool where
    Unt :
      static_eval_val (V, C) VUnt |
    Chan :
      static_eval_val (V, C) VChn c |
    SendEvt :
      static_eval_env (V, C) env %$\Longrightarrow$%
      static_eval_val (V, C) (VClsr (SendEvt _ _) env) |
    RecvEvt :
      static_eval_env (V, C) env %$\Longrightarrow$%
      static_eval_val (V, C) (VClsr (RecvEvt _) env) |
    Left :
      static_eval_env (V, C) env %$\Longrightarrow$%
      static_eval_val (V, C) (VClsr (Left _) env) |
    Right :
      static_eval_env (V, C) env %$\Longrightarrow$%
      static_eval_val (V, C) (VClsr (Right _) env) |
    Abs :
      {(APrim (Abs f x e)} %$\subseteq$% V f %$\Longrightarrow$% 
      static_eval_exp (V, C) e %$\Longrightarrow$% 
      static_eval_env (V, C) env %$\Longrightarrow$%
      static_eval_val (V, C) (VClsr (Abs f x e) env) |
    Pair :
      static_eval_env (V, C) env %$\Longrightarrow$%
      static_eval_val (V, C) (VClsr (Pair _ _) env) |
    intro :  
      %$\forall$% x v .
        env x = Some v %$\longrightarrow$%
        {abstract v} %$\subseteq$% V x %$\land$% static_eval_val (V, C) v %$\Longrightarrow$%
      static_eval_env (V, C) env

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive static_eval_stack ::
    abstract_env * abstract_env %$\Rightarrow$%
    abstract_value set %$\Rightarrow$% cont list %$\Rightarrow$% bool where
    Empty :
      static_eval_stack (V, C) valset [] |
    Nonempty : 
      valset %$\subseteq$% V x %$\Longrightarrow$%
      static_eval_exp (V, C) e %$\Longrightarrow$%
      static_eval_env (V, C) env %$\Longrightarrow$%
      static_eval_stack (V, C) (V (rslt_var e)) k %$\Longrightarrow$%
      static_eval_stack (V, C) valset ((Ctn x e env) # k)


  inductive static_eval_state ::
    abstract_env * abstract_env %$\Rightarrow$%
    state %$\Rightarrow$% bool where
    intro :
      static_eval_exp (V, C) e %$\Longrightarrow$%
      static_eval_env (V, C) env %$\Longrightarrow$%
      static_eval_stack (V, C) (V (rslt_var e)) k %$\Longrightarrow$%
      static_eval_state (V, C) (Stt e env k)

  inductive static_eval_pool ::
    abstract_env * abstract_env %$\Rightarrow$%
    trace_pool %$\Rightarrow$% bool where
    intro :
      %$\forall$% pi st .
        trpl pi = Some st %$\longrightarrow$%
        static_eval_state (V, C) st %$\Longrightarrow$% 
      static_eval_pool (V, C) trpl

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  theorem static_eval_preserved_under_concur_step :
    static_eval_pool (V, C) trpl %$\Longrightarrow$% 
    concur_step (trpl, ys) (trpl', ys') %$\Longrightarrow$%
    static_stati_eval_pool (V, C) trpl'
  proof sketch
  qed

  theorem static_eval_preserved_under_concur_step_star :
    static_eval_pool (V, C) trpl %$\Longrightarrow$% 
    star concur_step (trpl, ys) (trpl', ys')  %$\Longrightarrow$% 
    static_concur_step (V, C) trpl'
  proof sketch
  qed
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  theorem trace_pool_snapshot_not_static_bound_sound :
    env x = Some v %$\Longrightarrow$%
    trpl pi = Some (Stt e env k) %$\Longrightarrow$%
    static_eval_pool (V, C) trpl %$\Longrightarrow$%
    {abstract v} %$\subseteq$% V x
  proof sketch
  qed
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  theorem trace_pool_always_not_static_bound_sound :
    env' x = Some v %$\Longrightarrow$%
    static_eval_pool (V, C) trpl %$\Longrightarrow$% 
    star concur_step (trpl, ys) (trpl', ys') %$\Longrightarrow$%
    trpl' pi = Some (Stt e' env' k') %$\Longrightarrow$%
    {abstract v} %$\subseteq$% V x
  proof sketch
  qed

  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive
    static_reachable_left :: exp %$\Rightarrow$% exp %$\Rightarrow$% bool where
    Refl :
      static_reachable_left e0 e0 | 
    let_Spawn_Child :
      static_reachable_left e0 (Let x (Spwn ec) en)%$\Longrightarrow$%
      static_reachable_left e0 ec |
    let_Case_Left :
      static_reachable_left e0 (Let x (case xs xl el xr er) en) %$\Longrightarrow$%
      static_reachable_left e0 el |
    let_Case_Right :
      static_reachable_left e0 (Let x (case xs xl el xr er) en) %$\Longrightarrow$%
      static_reachable_left e0 er |
    let_Abs_Body :
      static_reachable_left e0 (Let x (Abs f xp eb) en) %$\Longrightarrow$%
      static_reachable_left e0 eb | 
    Let :
      static_reachable_left e0 (Let x b en) %$\Longrightarrow$%
      static_reachable_left e0 en

  inductive
    static_reachable_over_prim :: exp %$\Rightarrow$% prim %$\Rightarrow$% bool where
    SendEvt :
      static_reachable_over_prim e0 (SendEvt xC xM) |
    RecvEvt :
      static_reachable_over_prim e0 (RecvEvt xC) |
    Pair :
      static_reachable_over_prim e0 (Pair x1 x2) |
    Left :
      static_reachable_over_prim e0 (Left x) |
    Right :
      static_reachable_over_prim e0 (Right x) |
    Abs :
      static_reachable_left e0 eb %$\Longrightarrow$%
      static_reachable_over_prim e0 (Abs fp xp eb) 

  inductive 
    static_reachable_over_env :: exp %$\Rightarrow$% env %$\Rightarrow$% bool and
    static_reachable_over_val :: exp %$\Rightarrow$% val %$\Rightarrow$% bool where
    VUnt :
      static_reachable_over_val e0 VUnt |
    VChn :
      static_reachable_over_val e0 (VChn c) |
    VClsr : "
      static_reachable_over_prim e0 p %$\Longrightarrow$%
      static_reachable_over_env e0 env' %$\Longrightarrow$%
      static_reachable_over_val e0 (VClsr p env') |
    intro : "
      %$\forall$% x v .
        env x = Some v %$\longrightarrow$%
        static_reachable_over_val e0 v %$\Longrightarrow$%
      static_reachable_over_env e0 env

  inductive
    static_reachable_over_stack ::
      exp %$\Rightarrow$% cont list %$\Rightarrow$% bool where
    Empty :
      static_reachable_over_stack e0 [] |
    Nonempty :
      static_reachable_left e0 ek %$\Longrightarrow$%
      static_reachable_over_env e0 envk %$\Longrightarrow$%
      static_reachable_over_stack e0 k %$\Longrightarrow$%
      static_reachable_over_stack e0 ((Ctn xk ek envk) # k)

  inductive
    static_reachable_over_state ::
      exp %$\Rightarrow$% state %$\Rightarrow$% bool where
    intro :
      static_reachable_left e0 e %$\Longrightarrow$%
      static_reachable_over_env e0 env %$\Longrightarrow$%
      static_reachable_over_stack e0 k %$\Longrightarrow$%
      static_reachable_over_state e0 (Ctn e env k)

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  lemma static_reachable_trans :
    static_reachable ez ey %$\Longrightarrow$%
    static_reachable ey ex %$\Longrightarrow$%
    static_reachable ez ex
  proof sketch 
  qed


  lemma static_reachable_over_state_preserved :
    concur_step (trpl, ys) (trpl', ys') %$\Longrightarrow$%
    %$\forall$% pi st.
      trpl pi = Some st %$\longrightarrow$%
      static_reachable_over_state e0 st %$\Longrightarrow$%
    trpl' pi' = Some st' %$\Longrightarrow$%
    static_reachable_over_state e0 st'
  proof sketch 
  qed
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  lemma state_always_exp_not_static_reachable_sound :
    star concur_step (trpl0, ys0) (trpl', ys') %$\Longrightarrow$%
    trpl0 = [[] %$\mapsto$% (Stt e0 (%$\lambda$% _ . None) [])] %$\Longrightarrow$%
    trpl' pi' = Some st' %$\Longrightarrow$%
    static_reachable_over_state e0 st'
  proof sketch
  qed

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
    interpretation semantics_sound
    proof sketch
    qed
  \end{lstlisting}

\section{Static Communication}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
locale communication_sound =
  fixes 
    static_one_shot :: abstract_env %$\Rightarrow$% exp %$\Rightarrow$% var %$\Rightarrow$% bool and
    static_fan_out :: abstract_env %$\Rightarrow$% exp %$\Rightarrow$% var %$\Rightarrow$% bool and 
    static_fan_in :: abstract_env %$\Rightarrow$% exp %$\Rightarrow$% var %$\Rightarrow$% bool and
    static_one_to_one :: abstract_env %$\Rightarrow$% exp %$\Rightarrow$% var %$\Rightarrow$% bool

  assumes 
    static_one_shot_sound:
      static_one_shot V e xC %$\Longrightarrow$%
      static_eval (V, C) e %$\Longrightarrow$%
      star concur_step ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])], {}) (trpl', H') %$\Longrightarrow$%
      one_shot trpl' (Ch pi xC) and

    static_fan_out_sound: 
      static_fan_out V e xC %$\Longrightarrow$%
      (V, C) static_eval e %$\Longrightarrow$%
      star concur_step ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])], {}) (trpl', H') %$\Longrightarrow$%
      fan_out trpl' (Ch pi xC) and

    static_fan_in_sound:
      static_fan_in V e xC %$\Longrightarrow$%
      (V, C) static_eval e %$\Longrightarrow$%
      star concur_step ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])], {}) (trpl', H') %$\Longrightarrow$%
      fan_in trpl' (Ch pi xC) and

    static_one_to_one_sound: "
      static_one_to_one V e xC %$\Longrightarrow$%
      (V, C) static_eval e %$\Longrightarrow$%
      star concur_step ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])], {}) (trpl', H') %$\Longrightarrow$%
      one_to_one trpl' (Ch pi xC)"
  \end{lstlisting}



\begin{lstlisting}[style=codestyle1, escapechar=\%]
  datatype label = NLet var | NRslt var

  fun top_label :: exp %$\Rightarrow$% label where
    top_label (Let x b e) = NLet x |
    top_label (Rslt y) = NRslt y

  type_synonym label_set = label set

  type_synonym label_map = label %$\Rightarrow$% var set

  inductive
    static_static_send_label ::
      abstract_env %$\Rightarrow$% exp %$\Rightarrow$%
      var %$\Rightarrow$% label %$\Rightarrow$% bool where
    intro:
      {AChn xC} %$\subseteq$% V xSC %$\Longrightarrow$%
      {APrim (SendEvt xSC xM)} %$\subseteq$% V xE %$\Longrightarrow$%
      static_reachable e (Let x (Sync xE) e') %$\Longrightarrow$%
      static_static_send_label V e xC (NLet x)

  inductive
    static_static_recv_label ::
      abstract_env %$\Rightarrow$% exp %$\Rightarrow$%
      var %$\Rightarrow$% label %$\Rightarrow$% bool where
    intro:
      {AChn xC} %$\subseteq$% V xRC %$\Longrightarrow$%
      {APrim (RecvEvt xRC)} %$\subseteq$% V xE %$\Longrightarrow$%
      static_reachable e (Let x (Sync xE) e') %$\Longrightarrow$%
      static_static_recv_label V e xC (NLet x)

  \end{lstlisting}

\section{Static Communication part A}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  datatype mode = ENxt | ESpwn | ECall | ERtn

  type_synonym transition = label * mode * label

  type_synonym transition_set = transition set

  type_synonym step = label * mode

  type_synonym abstract_path = step list
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive
    static_traversable ::
      abstract_env %$\Rightarrow$%
      (label * mode * label) set %$\Rightarrow$%
      exp %$\Rightarrow$% bool  where
    Rslt:
      static_traversable V F (Rslt x) |
    let_Unit:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F e  %$\Longrightarrow$%
      static_traversable V F (Let x Unt e) |
    let_Chan:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x MkChn e) |
    let_SendEvt:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x = (SendEvt xc xm) e) |
    let_RecvEvt:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x = (RecvEvt xc) in e) |
    let_Pair:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x (Pair x1 x2) e) |
    let_Left:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x (Lft xp) e) |
    let_Right:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x (Rht xp) e)" |
    let_Abs:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F eb %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x (Abs f xp eb) e) |
    let_Spawn:
      {
        (NLet x, ENxt, top_label e),
        (NLet x, ESpwn, top_label ec)}
        %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F ec %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x (Spwn ec)  e) |
    let_Sync:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x (Sync xSE) e) |
    let_Fst:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x (Fst xp) e) |
    let_Snd:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x (Snd xp) e) |
    let_Case:
      {
        (NLet x, ECall, top_label el),
        (NLet x, ECall, top_label er),
        (NRslt (rslt_var el), ERtn, top_label e),
        (NRslt (rslt_var er), ERtn, top_label e)}
        %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F el %$\Longrightarrow$%
      static_traversable V F er %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_traversable V F (Let x (Case xs xl el xr er) e) |
    let_App:
      %$\forall$% fp xp eb .
        APrim (Abs fp xp eb) %$\in$% V f %$\longrightarrow$%
        {
          (NLet x, ECall, top_label eb),
          (NRslt (rslt_var eb), ERtn, top_label e)}
          %$\subseteq$% F %$\Longrightarrow$%
        static_traversable V F e %$\Longrightarrow$%
        static_traversable V F (Let x (App f xa) e)

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive static_traceable ::
    abstract_env %$\Rightarrow$%
      transition_set %$\Rightarrow$% label %$\Rightarrow$%
      (label %$\Rightarrow$% bool) %$\Rightarrow$%
      abstract_path %$\Rightarrow$% bool where
  Empty:
    isEnd start %$\Longrightarrow$%
    static_traceable V F start isEnd [] |
  Edge:
    isEnd end %$\Longrightarrow$%
    {(start, edge, end)} %$\subseteq$% F %$\Longrightarrow$%
    static_traceable V F start isEnd [(start, edge)] |
  Step:
    static_traceable V F middle isEnd ((middle, edge') # path) %$\Longrightarrow$%
    {(start, edge, middle)} %$\subseteq$% F %$\Longrightarrow$%
    static_traceable V F start isEnd ((start, edge) # (middle, edge') # path)
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive static_inclusive ::
    abstract_path %$\Rightarrow$% abstract_path %$\Rightarrow$% bool where
  Prefix1:
    prefix pi1 pi2 %$\Longrightarrow$%
    static_inclusive pi1 pi2 |
  Prefix2:
    prefix pi2 pi1 %$\Longrightarrow$%
    static_inclusive pi1 pi2 |
  Spawn1:
    static_inclusive (pi @ (NLet x, ESpwn) # pi1) (pi @ (NLet x, ENxt) # pi2) |
  Spawn2:
    static_inclusive (pi @ (NLet x, ENxt) # pi1) (pi @ (NLet x, ESpwn) # pi2)
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive
    singular ::
      abstract_path %$\Rightarrow$%
      abstract_path %$\Rightarrow$% bool where
  equal:
    pi1 = pi2 %$\Longrightarrow$% 
    singular pi1 pi2 |
  exclusive:
    %$\not$% (static_inclusive pi1 pi2) %$\Longrightarrow$% 
    singular pi1 pi2

  inductive
    noncompetitive ::
      abstract_path %$\Rightarrow$% abstract_path %$\Rightarrow$% bool where
    ordered:
      ordered pi1 pi2 %$\Longrightarrow$% 
      noncompetitive pi1 pi2 |
    exclusive:
      %$\not$% (not_inclusive pi1 pi2) %$\Longrightarrow$% 
      noncompetitive pi1 pi2
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive
    static_one_shot ::
      abstract_env %$\Rightarrow$% exp %$\Rightarrow$%
      var %$\Rightarrow$% bool where
    Sync:
      every_two
        (static_traceable V F (top_label e)
          (static_static_send_label V e xC))
        singular %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_one_shot V e xC 

    inductive
      static_one_to_one ::
        abstract_env %$\Rightarrow$% exp %$\Rightarrow$%
        var %$\Rightarrow$% bool where
      Sync:
        every_two
          (static_traceable V F
            (top_label e) (static_static_send_label V e xC))
          noncompetitive %$\Longrightarrow$%
        every_two
          (static_traceable V F
            (top_label e) (static_static_recv_label V e xC))
          noncompetitive %$\Longrightarrow$%
        static_traversable V F e %$\Longrightarrow$%
        static_one_to_one V e xC 

  inductive
    static_fan_out ::
      abstract_env %$\Rightarrow$% exp %$\Rightarrow$%
      var %$\Rightarrow$% bool where
    Sync:
      every_two
        (static_traceable V F
          (top_label e) (static_static_send_label V e xC))
        noncompetitive %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_fan_out V e xC 

  inductive
    static_fan_in ::
      abstract_env %$\Rightarrow$% exp %$\Rightarrow$%
      var %$\Rightarrow$% bool where
    Sync:
      every_two (static_traceable V F (top_label e) (static_static_recv_label V e xC)) noncompetitive %$\Longrightarrow$%
      static_traversable V F e %$\Longrightarrow$%
      static_fan_in V e xC

    \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
locale communication_sound_A = 
  Static_Communication.communication_sound static_one_shot static_fan_out static_fan_in static_one_to_one
    \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive paths_correspond ::
    control_path %$\Rightarrow$% abstract_path %$\Rightarrow$% bool where
    Empty:
      paths_correspond [] [] |
    Next:
      paths_correspond pi path %$\Longrightarrow$%
      paths_correspond (pi @ [LNext x]) (path @ [(NLet x, ENxt)]) |
    Spawn:
      paths_correspond pi path %$\Longrightarrow$%
      paths_correspond (pi @ [LSpawn x]) (path @ [(NLet x, ESpwn)]) |
    Call:
      paths_correspond pi path %$\Longrightarrow$%
      paths_correspond (pi @ [LCall x]) (path @ [(NLet x, ECall)])  |
    Rtn:
      paths_correspond pi path %$\Longrightarrow$%
      paths_correspond (pi @ [LRtn x]) (path @ [(NRslt x, ERtn)]) 
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  lemma not_static_inclusive_sound: "
    star concur_step
      ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])], {})
      (trpl', ys') %$\Longrightarrow$% 
    trpl' pi1 %$\neq$% None %$\Longrightarrow$% 
    trpl' pi2 %$\neq$% None %$\Longrightarrow$% 
    paths_correspond pi1 path1 %$\Longrightarrow$%
    paths_correspond pi2 path2 %$\Longrightarrow$%
    static_inclusive path1 path2"

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive 
    static_traversable_env ::
      abstract_env %$\Rightarrow$% transition_set %$\Rightarrow$% env %$\Rightarrow$% bool and
    static_traversable_val ::
      abstract_env %$\Rightarrow$% transition_set %$\Rightarrow$% val %$\Rightarrow$% bool where
    Intro:
      %$\forall$% x v .
        env x = Some v %$\longrightarrow$%
        {rslt_var v} %$\subseteq$% V x %$\land$% static_traversable_val V F v %$\Longrightarrow$%
      static_traversable_env V F env |

    Unit:
      static_traversable_val V F VUnit |
    Chan:
      static_traversable_val V F (VChn c) |
    SendEvt:
      static_traversable_env V F env %$\Longrightarrow$%
      static_traversable_val V F (VClsr (SendEvt _ _) env) |
    RecvEvt:
      static_traversable_env V F env %$\Longrightarrow$%
      static_traversable_val V F (VClsr (RecvEvt _) env) |
    Left:
      static_traversable_env V F env %$\Longrightarrow$%
      static_traversable_val V F (VClsr (Left _) env) |
    Right:
      static_traversable_env V F env %$\Longrightarrow$%
      static_traversable_val V F (VClsr (Right _) env) |
    Abs:
      static_traversable V F e %$\Longrightarrow$% 
      static_traversable_env V F  env %$\Longrightarrow$%
      static_traversable_val V F (VClsr (Abs f x e) env) |
  Pair:
    static_traversable_env V F env %$\Longrightarrow$%
    static_traversable_val V F (VClsr (Pair _ _) env) 



  inductive static_traversable_stack ::
    abstract_env %$\Rightarrow$% transition_set %$\Rightarrow$% cont list %$\Rightarrow$% bool where
    Empty:
      static_traversable_stack V F [] |
    Nonempty:
      static_traversable V F e %$\Longrightarrow$%
      static_traversable_env V F env %$\Longrightarrow$%
      static_traversable_stack V F k %$\Longrightarrow$% 
      static_traversable_stack V F ((Ctn x e env) # k))

  inductive
    static_traversable_pool ::
      abstract_env %$\Rightarrow$% transition_set %$\Rightarrow$%
      trace_pool %$\Rightarrow$% bool  where
    Intro:
      %$\forall$% pi e env k .
        E pi = Some (Stt e env k) %$\longrightarrow$% 
        static_traversable V F e %$\land$%
        static_traversable_env V F env %$\land$%
        static_traversable_stack V F k %$\Longrightarrow$% 
      static_traversable_pool V F E

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]


  lemma static_traversable_pool_preserved_star: "
    static_traversable_pool V F
      ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])]) %$\Longrightarrow$%
    static_eval (V, C) e %$\Longrightarrow$%
    trpl' pi = Some (Stt (Let x b en) envk) %$\Longrightarrow$%
    star concur_step
      ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])], {})
      (trpl', ys') %$\Longrightarrow$%
    isEnd (NLet x) %$\Longrightarrow$%
    static_traversable_pool V F trpl' "
  proof sketch
  qed

lemma static_traversable_pool_implies_static_traceable: "
  trpl' pi = Some (Stt (Let x b in en) env k) %$\Longrightarrow$%
  concur_step
    ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])], {})
    (trpl', ys') %$\Longrightarrow$% 
  static_eval (V, C) e %$\Longrightarrow$%
  static_traversable_pool V F trpl' %$\Longrightarrow$%
  isEnd (NLet x) %$\Longrightarrow$%
  %$\exists$% path . 
    paths_correspond pi path %$\land$%
    static_traceable V F (top_label e) isEnd path "
  proof sketch
  qed
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  lemma not_static_traceable_sound: "
  trpl' pi = Some (Stt (Let x b en) env k) %$\Longrightarrow$%
  star concur_step
    ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])], {})
    (trpl', ys') %$\Longrightarrow$% 
  static_eval (V, C) e %$\Longrightarrow$%
  static_traversable V F e %$\Longrightarrow$%
  isEnd (NLet x) %$\Longrightarrow$%
  %$\exists$% path . 
    paths_correspond pi path %$\land$%
    static_traceable V F (top_label e) isEnd path
  proof sketch
  qed
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]


  interpretation communication_sound_A
    proof -

  \end{lstlisting}



\section{Static Communication part B}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
datatype mode = ENxt | ESpwn | ESend var | ECall | ERtn var

type_synonym transition = (label * mode * label)

type_synonym transition_set = transition set

type_synonym step = (label * mode)

type_synonym abstract_path = step list
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive static_traversable :: abstract_env %$\Rightarrow$% transition_set %$\Rightarrow$% (var %$\Rightarrow$% label %$\Rightarrow$% bool) %$\Rightarrow$% exp %$\Rightarrow$% bool  where
    result:
        static_traversable V F static_recv_site (Rslt x) |
    let_Unit:
        {(NLet x , ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
        static_traversable V F static_recv_site e %$\Longrightarrow$%
        static_traversable V F static_recv_site (Let x Unt e) |
    let_Chan:
        {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
        static_traversable V F static_recv_site e %$\Longrightarrow$%
        static_traversable V F static_recv_site (Let x MkChn e) |
  let_SendEvt:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F static_recv_site e %$\Longrightarrow$%
      static_traversable V F static_recv_site (Let x (Prim (SendEvt xc xm)) e)" |
  let_RecvEvt:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F static_recv_site e %$\Longrightarrow$%
      static_traversable V F static_recv_site (Let x (Prim (RecvEvt xc)) e) |
  let_Pair:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F static_recv_site e %$\Longrightarrow$%
      static_traversable V F static_recv_site (Let x (Prim (Pair x1 x2)) e) |
  let_Left:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F static_recv_site e %$\Longrightarrow$%
      static_traversable V F static_recv_site (Let x (Prim (Lft xp)) e) |
  let_Right:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F static_recv_site e %$\Longrightarrow$%
      static_traversable V F static_recv_site (Let x (Prim (Rght xp)) e) |
  let_Abs:
    {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
    static_traversable V F static_recv_site eb %$\Longrightarrow$%
    static_traversable V F static_recv_site e %$\Longrightarrow$%
    static_traversable V F static_recv_site (Let x (Prim (Abs f xp eb)) e) |
  let_Spawn:
    {(NLet x, ENxt, top_label e),
      (NLet x, ESpawn, top_label ec)} %$\subseteq$% F %$\Longrightarrow$%
    static_traversable V F static_recv_site ec %$\Longrightarrow$%
    static_traversable V F static_recv_site e %$\Longrightarrow$%
    static_traversable V F static_recv_site (Let x (Spwn ec) e) |
  let_Sync:
    {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
    (%$\forall$% xSC xM xC y .
      {^SendEvt xSC xM} %$\subseteq$% V xSE %$\longrightarrow$%
      {^Chan xC} %$\subseteq$% V xSC %$\longrightarrow$%
      static_recv_site xC (NLet y) %$\longrightarrow$%
      {(NLet x, ESend xSE, NLet y)} %$\subseteq$% F) %$\Longrightarrow$%
    static_traversable V F static_recv_site e %$\Longrightarrow$%
    static_traversable V F static_recv_site (Let x (Sync xSE) e) |
  let_Fst:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F static_recv_site e %$\Longrightarrow$%
      static_traversable V F static_recv_site (Let x (Fst xp) e) |
  let_Snd:
      {(NLet x, ENxt, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F static_recv_site e %$\Longrightarrow$%
      static_traversable V F static_recv_site (Let x (Snd xp) e) |
  let_Case:
      {
        (NLet x, ECall, top_label el),
        (NLet x, ECall, top_label er),
        (NRslt (rslt_var el), ERtn x, top_label e),
        (NRslt (rslt_var er), ERtn x, top_label e)} %$\subseteq$% F %$\Longrightarrow$%
      static_traversable V F static_recv_site el %$\Longrightarrow$%
      static_traversable V F static_recv_site er %$\Longrightarrow$%
      static_traversable V F static_recv_site e %$\Longrightarrow$%
      static_traversable V F static_recv_site (Let x (Case xs xl el xr er) e) |
  let_App:
      (%$\forall$% f' xp eb . ^Abs f' xp eb %$\in$% V f %$\longrightarrow$%
        {(NLet x, ECall, top_label eb),
          (NRslt (rslt_var eb), ERtn x, top_label e)} %$\subseteq$% F) %$\Longrightarrow$%
      static_traversable V F static_recv_site e %$\Longrightarrow$%
    static_traversable V F static_recv_site (Let x (App f xa) e)

  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
inductive 
  static_built_on_chan :: "abstract_env %$\Rightarrow$% label_map %$\Rightarrow$% var %$\Rightarrow$% var %$\Rightarrow$% bool"
where
  Chan:
      AChn xc %$\in$% V x %$\Longrightarrow$% 
      static_built_on_chan V Ln xc x |
  SendEvt: 
      APrim (SendEvt xsc xm) %$\in$% V x %$\Longrightarrow$% 
      static_built_on_chan V Ln xc xsc %$\lor$% static_built_on_chan V Ln xc xm %$\Longrightarrow$% 
      static_built_on_chan V Ln xc x |
  RecvEvt:
    APrim (RecvEvt xrc) %$\in$% V x %$\Longrightarrow$% 
    static_built_on_chan V Ln xc xrc %$\Longrightarrow$% 
    static_built_on_chan V Ln xc x |
  Pair:
      APrim (Pair x1 x2) %$\in$% V x %$\Longrightarrow$%
      static_built_on_chan V Ln xc x1 %$\lor$% static_built_on_chan V Ln xc x2 %$\Longrightarrow$% 
      static_built_on_chan V Ln xc x |
  Left:
      APrim (Left xa) %$\in$% V x %$\Longrightarrow$% 
      static_built_on_chan V Ln xc xa %$\Longrightarrow$% 
    static_built_on_chan V Ln xc x |
  Right:
      APrim (Right xa) %$\in$% V x %$\Longrightarrow$% 
      static_built_on_chan V Ln xc xa %$\Longrightarrow$% 
      static_built_on_chan V Ln xc x |
  Abs:
    APrim (Abs f xp eb) %$\in$% V x %$\Longrightarrow$% 
    %$\not$% Set.is_empty (Ln (labelLabel eb) - {xp}) %$\Longrightarrow$%
    static_built_on_chan V Ln xc x 
  \end{lstlisting}



\begin{lstlisting}[style=codestyle1, escapechar=\%]
  fun chan_set ::
    abstract_env %$\Rightarrow$% label_map %$\Rightarrow$% var %$\Rightarrow$% var %$\Rightarrow$% var set" where
    chan_set V Ln xc x = (if (static_built_on_chan V Ln xc x) then {x} else {})
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive static_live_chan ::
    abstract_env %$\Rightarrow$% label_map %$\Rightarrow$% label_map %$\Rightarrow$% var %$\Rightarrow$% exp %$\Rightarrow$% bool where
    Result:
      chan_set V Ln xc y = Ln (NRslt y) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Rslt y) |
  Let_Unit:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
      Lx (NLet x) = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x Unt e) |
  Let_Chan:
    static_live_chan V Ln Lx xc e %$\Longrightarrow$%
    Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
    (Lx (NLet x) - {x}) = Ln (NLet x) %$\Longrightarrow$%
    static_live_chan V Ln Lx xc (Let x MkChn e) |
  Let_SendEvt:
    static_live_chan V Ln Lx xc e %$\Longrightarrow$%
    Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
    (Lx (NLet x) - {x}) %$\cup$% chan_set V Ln xc xsc %$\cup$%
      chan_set V Ln xc xm = Ln (NLet x) %$\Longrightarrow$%
    static_live_chan V Ln Lx xc (Let x (Prim (SendEvt xsc xm)) e) |
  Let_RecvEvt:
    static_live_chan V Ln Lx xc e %$\Longrightarrow$%
    Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
    (Lx (NLet x) - {x}) %$\cup$% chan_set V Ln xc xrc = Ln (NLet x) %$\Longrightarrow$%
    static_live_chan V Ln Lx xc (Let x (Prim (RecvEvt xrc)) e) |
  Let_Pair:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
      (Lx (NLet x) - {x}) %$\cup$%  chan_set V Ln xc x1 %$\cup$%
        chan_set V Ln xc x2 = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x (Prim (Pair x1 x2)) e) |
  Let_Left:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
      (Lx (NLet x) - {x}) %$\cup$% chan_set V Ln xc xa = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x (Prim (Lft xa)) e) |
  Let_Right:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
      (Lx (NLet x) - {x}) %$\cup$% chan_set V Ln xc xa = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x (Prim (Rght xa)) e) |
  Let_Abs:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc eb %$\Longrightarrow$%
      (Lx (NLet x) - {x}) %$\cup$%
        (Ln (top_label eb) - {xp}) = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x (Prim (Abs f xp eb)) e) |
  Let_Spawn:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      static_live_chan V Ln Lx xc ec %$\Longrightarrow$%
      Ln (top_label e) %$\cup$% Ln (top_label ec) = Lx (NLet x) %$\Longrightarrow$%
      (Lx (NLet x) - {x}) = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x (Spwn ec) e) |
  Let_Sync:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
      (Lx (NLet x) - {x}) %$\cup$% chan_set V Ln xc xe = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x (Sync xe) e) |
  Let_Fst:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
      (Lx (NLet x) - {x}) %$\cup$% chan_set V Ln xc xa = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x (Fst xa) e) |
  Let_Snd:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
      (Lx (NLet x) - {x}) %$\cup$% chan_set V Ln xc xa = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x (Snd xa) e) |
  Let_Case:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc el %$\Longrightarrow$%
      static_live_chan V Ln Lx xc er %$\Longrightarrow$%
      (Lx (NLet x) - {x}) %$\cup$% chan_set V Ln xc xs %$\cup$% 
      (Ln (top_label el) - {xl}) %$\cup$%
      (Ln (top_label er) - {xr}) = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x (Case xs xl el xr er) e) |
  Let_App:
      static_live_chan V Ln Lx xc e %$\Longrightarrow$%
      Ln (top_label e) = Lx (NLet x) %$\Longrightarrow$%
      (Lx (NLet x) - {x}) %$\cup$%
      chan_set V Ln xc f %$\cup$%
      chan_set V Ln xc xa = Ln (NLet x) %$\Longrightarrow$%
      static_live_chan V Ln Lx xc (Let x (App f xa) e)


  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive static_traceable ::
    transition_set %$\Rightarrow$% label
    %$\Rightarrow$% abstract_path %$\Rightarrow$% bool" where
    Empty:
      static_traceable F end [] |
    Edge:
      (start, edge, end) %$\in$% F %$\Longrightarrow$%
      static_traceable F end [(start, edge)] |
    Step:
      static_traceable F end ((middle, edge') # post) %$\Longrightarrow$%
      (start, edge, middle) %$\in$% F %$\Longrightarrow$%
      path = [(start, edge), (middle, edge')] @ post %$\Longrightarrow$%
      static_traceable F end path

  \end{lstlisting}



\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive static_live_traversable :: "transition_set %$\Rightarrow$% label_map %$\Rightarrow$% label_map %$\Rightarrow$% transition %$\Rightarrow$% bool"  where
  Next: "
    (l, ENxt, l') %$\in$% F %$\Longrightarrow$%
    %$\not$% Set.is_empty (Lx l) %$\Longrightarrow$%
    %$\not$% Set.is_empty (Ln l') %$\Longrightarrow$%
    static_live_traversable F Ln Lx (l, ENxt, l')
  " |
  Spawn: "
    (l, ESpwn, l') %$\in$% F %$\Longrightarrow$%
    %$\not$% Set.is_empty (Lx l) %$\Longrightarrow$%
    %$\not$% Set.is_empty (Ln l') %$\Longrightarrow$%
    static_live_traversable F Ln Lx (l, ESpwn, l')
  " |
  Call_Live_Outer: "
    (l, ECall, l') %$\in$% F %$\Longrightarrow$%
    %$\not$% Set.is_empty (Lx l) %$\Longrightarrow$%
    static_live_traversable F Ln Lx (l, ECall, l')
  " |
  Call_Live_Inner: "
    (l, ECall, l') %$\in$% F %$\Longrightarrow$%
    %$\not$% Set.is_empty (Ln l') %$\Longrightarrow$%
    static_live_traversable F Ln Lx (l, ECall, l')
  " |
  Return: "
    (l, ERtn x, l') %$\in$% F %$\Longrightarrow$%
    %$\not$% Set.is_empty (Ln l') %$\Longrightarrow$%
    static_live_traversable F Ln Lx (l, ERtn x, l')
  " |
  Send: "
    ((NLet xSend), ESend xE, (NLet xRecv)) %$\in$% F %$\Longrightarrow$%
    {xE} %$\subseteq$% (Ln (NLet xSend)) %$\Longrightarrow$%
    static_live_traversable F Ln Lx ((NLet xSend), ESend xE, (NLet xRecv))
    "
    
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  
inductive static_live_traceable :: "abstract_env %$\Rightarrow$% transition_set %$\Rightarrow$% label_map %$\Rightarrow$% label_map %$\Rightarrow$% label %$\Rightarrow$% (label %$\Rightarrow$% bool) %$\Rightarrow$% abstract_path %$\Rightarrow$% bool" where
  Empty:
    isEnd start %$\Longrightarrow$%
    static_live_traceable V F Ln Lx start isEnd [] |
  Edge:
    isEnd end %$\Longrightarrow$%
    static_live_traversable F Ln Lx (start, edge, end) %$\Longrightarrow$%
    static_live_traceable V F Ln Lx start isEnd [(start, edge)] |
  Step:
    static_live_traceable V F Ln Lx middle isEnd ((middle, edge') # path) %$\Longrightarrow$%
    static_live_traversable F Ln Lx (start, edge, middle) %$\Longrightarrow$%
    static_live_traceable V F Ln Lx start isEnd ((start, edge) # (middle, edge') # path) |
  Pre_Return:
    static_live_traceable V F Ln Lx (NRslt y) isEnd ((NRslt y, ERtn x) # post) %$\Longrightarrow$%
    static_traceable  F (NRslt y) pre %$\Longrightarrow$%
    %$\not$% static_balanced (pre @ [(NRslt y, ERtn x)]) %$\Longrightarrow$%
    %$\not$% Set.is_empty (Lx (NLet x)) %$\Longrightarrow$%
    path = pre @ (NRslt y, ERtn x) # post %$\Longrightarrow$%
    static_live_traceable V F Ln Lx start isEnd path
    
  \end{lstlisting}



\begin{lstlisting}[style=codestyle1, escapechar=\%]

  
  inductive static_inclusive ::
    abstract_path %$\Rightarrow$% abstract_path %$\Rightarrow$% bool where
  Prefix1:
    prefix pi1 pi2 %$\Longrightarrow$%
    pi1 static_inclusive pi2 |
  Prefix2:
    prefix pi2 pi1 %$\Longrightarrow$%
    pi1 static_inclusive pi2 |
  Spawn1:
    static_inclusive (pi @ (NLet x, ESpwn) # pi1) (pi @ (NLet x, ENxt) # pi2) |
  Spawn2:
    static_inclusive (pi @ (NLet x, ENxt) # pi1 static_inclusive) (pi @ (NLet x, ESpwn) # pi2) |
  Send1: 
    static_inclusive (pi @ (NLet x, ESend xE) # pi1) (pi @ (NLet x, ENxt) # pi2) |
  Send2:
    static_inclusive (pi @ (NLet x, ENxt) # pi1) (pi @ (NLet x, ESend xE) # pi2)
    
  \end{lstlisting}



\begin{lstlisting}[style=codestyle1, escapechar=\%]


  
  inductive singular ::
    abstract_path %$\Rightarrow$% abstract_path %$\Rightarrow$% bool where
    equal:
      pi1 = pi2 %$\Longrightarrow$% 
      singular pi1 pi2 |
    exclusive:
      %$\not$% (pi1 static_inclusive pi2) %$\Longrightarrow$% 
      singular pi1 pi2

    inductive noncompetitive ::
      abstract_path %$\Rightarrow$% abstract_path %$\Rightarrow$% bool" where
  ordered:
    ordered pi1 pi2 %$\Longrightarrow$% 
    noncompetitive pi1 pi2 |
  exclusive:
    %$\not$% (pi1 static_inclusive pi2) %$\Longrightarrow$% 
    noncompetitive pi1 pi2

inductive static_one_shot :: abstract_env %$\Rightarrow$% exp %$\Rightarrow$% var %$\Rightarrow$% bool where
  Sync:
    every_two (static_live_traceable V F Ln Lx (NLet xC) (static_send_label V e xC)) singular %$\Longrightarrow$%
    static_live_chan V Ln Lx xC e %$\Longrightarrow$%
    static_traversable V F (static_recv_label V e) e %$\Longrightarrow$%
    static_one_shot V e xC

inductive static_one_to_one :: abstract_env %$\Rightarrow$% exp %$\Rightarrow$% var %$\Rightarrow$% bool where
  Sync:
    every_two (static_live_traceable V F Ln Lx (NLet xC) (static_send_label V e xC)) noncompetitive %$\Longrightarrow$%
    every_two (static_live_traceable V F Ln Lx (NLet xC) (static_recv_label V e xC)) noncompetitive %$\Longrightarrow$%
    static_live_chan V Ln Lx xC e %$\Longrightarrow$%
    static_traversable V F (static_recv_label V e) e %$\Longrightarrow$%
    static_one_to_one V e xC

inductive static_fan_out :: abstract_env %$\Rightarrow$% exp %$\Rightarrow$% var %$\Rightarrow$% bool where
  Sync:
    every_two (static_live_traceable V F Ln Lx (NLet xC) (static_send_label V e xC)) noncompetitive %$\Longrightarrow$%
    static_live_chan V Ln Lx xC e %$\Longrightarrow$%
    static_traversable V F (static_recv_label V e) e %$\Longrightarrow$%
    static_fan_out V e xC

inductive static_fan_in :: abstract_env %$\Rightarrow$% exp %$\Rightarrow$% var %$\Rightarrow$% bool where
  Sync:
    every_two (static_live_traceable V F Ln Lx (NLet xC) (static_recv_label V e xC)) noncompetitive %$\Longrightarrow$%
    static_live_chan V Ln Lx xC e %$\Longrightarrow$%
    static_traversable V F (static_recv_label V e) e %$\Longrightarrow$%
    static_fan_in V e xC

  \end{lstlisting}
    
\begin{lstlisting}[style=codestyle1, escapechar=\%]
locale communication_sound_B =
  Static_Communication.communication_sound static_one_shot static_fan_out static_fan_in static_one_to_one
    \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
interpretation communication_sound_B
proof sketch
qed
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]


  let lp = fun lp x => 
    let z1 = case x of 
      L y => let z2 = lp y in z2 |
      R () => let z3 = () in z3
      in ()
    in

  let mksr = fun _ x => 
    let ch1 = mkChan ()  in
    let z4 = (lp (L (L (R ()))) in
    let srv = fun srv x  =>
      let p = sync (recv_evt ch1) in
      let v1 = fst p in
      let ch2 = snd p in 
      let z5 = sync (send_evt ch2 x) in
      let z6 = srv v1 in ()
      in
    let z7 = spawn (
      let z8 = srv (R ()) in ()) in
    ch1 in

  let rqst = fun _ pair =>
    let ch3 = fst pair in
    let v2 = snd pair in
    let ch4 = chan () in
    let z9 = sync (send_evt ch3 (v2, ch4)) in
    let v3 = sync (recv_evt ch4) in
    v3 in

  let srvr = mksr () in
  let z10 = spawn ( 
    let z11 = rqst (srvr, R ()) in ())
    in
  let z12 = rqst (srvr, L (R ())) in
  () 

  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  \end{lstlisting}



\end{document}
\end{document}
{Document}
