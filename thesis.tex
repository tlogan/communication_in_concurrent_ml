\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}



\usepackage[utf8]{inputenc}
 
\usepackage{listings}
\usepackage{color}
 
\iffalse
  \definecolor{codegreen}{rgb}{0,0.6,0}
  \definecolor{codegray}{rgb}{0.5,0.5,0.5}
  \definecolor{codepurple}{rgb}{0.58,0,0.82}
  \definecolor{backcolour}{rgb}{0.95,0.95,0.92}
  backgroundcolor=\color{backcolour},   
  commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\small\color{codegray},
  stringstyle=\color{codepurple},
\fi
 
\lstdefinestyle{codestyle1}{
  basicstyle=\ttfamily\small,
  breakatwhitespace=false,     
  breaklines=true,         
  captionpos=b,          
  keepspaces=true,         
  numbers=left,          
  numbersep=5pt,          
  showspaces=false,        
  showstringspaces=false,
  showtabs=false,          
  tabsize=2
}
 




\title{Formal Theory of Communication Topology in Concurrent ML}
\author{Thomas Logan}
\begin{document}

\maketitle
\pagenumbering{gobble}

\newpage
\pagenumbering{arabic}

\section{Mathematical Artifacts}

\begin{lstlisting}[language=ML, style=codestyle1]
  type thread_id
  val spawn : (unit -> unit) -> thread_id

  type 'a chan
  val channel : unit -> 'a chan
  val recv : 'a chan -> 'a
  val send : ('a chan * 'a) -> unit
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]

  signature SERV = sig 
    type serv
    val make : unit -> serv
    val call : serv * int -> int
  end

  structure Serv : SERV = struct 
    datatype serv = S of (int * int chan) chan 

    fun make () = let 
      val reqChn = channel ()
      fun loop state = let
        val (v, replCh) = recv reqChn in 
        send (replCh, state);
        loop v end in
      spawn (fn () => loop 0);
      S reqChn end 

    fun call (server, v) = let 
      val S reqChn = server
      val replChn = channel () in 
      send (reqCh, (v, replCh));
      recv replChn end end

  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]

  type 'a event
  val sync : 'a event -> 'a
  val recvEvt : 'a chan -> 'a event
  val sendEvt : 'a chan * 'a -> unit event
  val choose : 'a event * 'a event -> 'a event

  fun send (ch, v) = sync (sendEvt (ch, v))
  fun recv v = sync (recvEvt v)

  val thenEvt : 'a event * ('a -> 'b event) -> 'b event

  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  val server = Serv.make ()
  val _ = spawn (fn () => Serv.call (server, 35))
  val _ = spawn (fn () => 
    Serv.call (server, 12); 
    Serv.call (server, 13))
  val _ = spawn (fn () => Serv.call (server, 81))
  val _ = spawn (fn () => Serv.call (server, 44))
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  structure Serv : SERV = struct 
    datatype serv = S of (int * int chan) chan 

    fun make () = let 

      val reqChn = FanIn.channel()

      fun loop state = let
        val (v, replCh) = FanIn.recv reqChn in 
        OneShot.send (replCh, state);
        loop v end in

      spawn (fn () => loop 0);
      S reqChn end 

    fun call (server, v) = let 
      val S reqChn = server
      val replChn = OneShot.channel () in 
      FanIn.send (reqCh, (v, replCh));
      OneShot.recv replChn end

    end
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  let
    val w = 4
    val x = ref 1
    val y = ref 2
    val z = (!x + 1) + (!y + 2) + (w - 3)
    val w = 1 in
    y := 0;
    (!y + 2) - (!x + 1) * (w - 3) end
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  let 
    val x = 1  
    val y = 2
    val z = ref (4 * 73)
    val x = 4 in 
    z := 1; 
    x * !z end
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]

  let 
    val f = fn x => x 1
    val g = fn y => y + 2
    val h = fn z => z + 3 in 
    (f g) + (f h) end

\end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  datatype 'a list = Nil | Cons 'a ('a list)

  inductive
    sorted ::
      ('a %$\Rightarrow$% 'a %$\Rightarrow$% bool) %$\Rightarrow$%
      'a list %$\Rightarrow$% bool where
    Nil : sorted P Nil |
    Single : sorted P (Cons x Nil) |
    Cons :
      P x y %$\Longrightarrow$%
      sorted P (Cons y ys) %$\Longrightarrow$%
      sorted P (Cons x (Cons y ys))
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  datatype nat = Z | S nat 

  inductive
    lte ::
      nat %$\Rightarrow$% nat %$\Rightarrow$% bool where
    Eq : lte n n |
    Lt : lte n1 n2 %$\Longrightarrow$% lte n1 (S n2)

  theorem "
    sorted lte
      (Cons (Z) (Cons (S Z)
        (Cons (S Z) (Cons
          (S (S (S Z))) Nil))))"
    apply (rule Cons)
    apply (rule Lt)
    apply (rule Eq)
    apply (rule Cons)
    apply (rule Eq)
    apply (rule Cons)
    apply (rule Lt)
    apply (rule Lt)
    apply (rule Eq)
    apply (rule Single)
    done
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  definition True :: bool where 
    True %$\equiv$% ((%$\lambda$%x ::bool. x) = (%$\lambda$%x. x))

  definition False :: bool where 
    False %$\equiv$% (%$\forall$%P. P)

  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  signature CHAN = sig
    type 'a chan 
    val channel : unit -> 'a chan
    val send : 'a chan * 'a -> unit
    val recv : 'a chan -> 'a
    end     
\end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]

  structure ManyToManyChan : CHAN = struct
    type message_queue = 'a option ref queue

    datatype 'a chan_content = 
      Send of (condition * 'a) queue | 
      Recv of (condition * 'a option ref) queue | 
      Inac

    datatype 'a chan =
      Chn of 'a chan_content ref * mutex_lock 

    fun channel () = Chn (ref Inac, mutexLock ())

    fun send (Chn (conRef, lock)) m = 
      acquire lock;
      (case !conRef of
        Recv q => let
          val (recvCond, mopRef) = dequeue q in
          mopRef := Some m;
          if (isEmpty q) then conRef := Inac else (); 
          release lock; signal recvCond; () end |
        Send q => let
          val sendCond = condition () in
          enqueue (q, (sendCond, m));
          release lock; wait sendCond; () end |
        Inac => let
          val sendCond = condition () in
          conRef := Send (queue [(sendCond, m)]);
          release lock; wait sendCond; () end)

    fun recv (Chn (conRef, lock)) =  
      acquire lock;
      (case !conRef of 
        Send q => let
          val (sendCond, m) = dequeue q in
          if (isEmpty q) then
            conRef := Inac
          else
            (); 
          release lock; signal sendCond; m end |
        Recv q => let
          val recvCond = condition ()
          val mopRef = ref None in
          enqueue (q, (recvCond, mopRef));
          release lock; wait recvCond;
          valOf (!mopRef) end |
        Inac => let
          val recvCond = condition ()
          val mopRef = ref None in
          conRef := Recv (queue [(recvCond, mopRef)]);
          release lock; wait recvCond;
          valOf (!mopRef) end)

    end

  \end{lstlisting}

  \begin{lstlisting}[language=ML, style=codestyle1]

    structure FanOutChan : CHAN = struct

    datatype 'a chan_content =
      Send of condition * 'a |
      Recv of (condition * 'a option ref) queue  |
      Inac

    datatype 'a chan =
      Chn of 'a chan_content ref * mutex_lock

    fun channel () = Chn (ref Inac, mutexLock ())

    fun send (Chn (conRef, lock)) m = let
      val sendCond = condition () in
      case cas (conRef, Inac, Send (sendCond, m)) of
        Inac => (* conRef already set *)
          wait sendCond; () |
        Recv q => 
        (* the current thread is
          * the only one that updates from this state *)
          acquire lock;
          (let
            val (recvCond, mopRef) = dequeue q in
            mopRef := Some m; 
            if (isEmpty q) then conRef := Inac else (); 
            release lock; signal (recvCond);
            () end) |
        Send _ => raise NeverHappens end

    fun recv (Chn (conRef, lock)) =
      acquire lock;
      (case !conRef of
        Inac => let
          val recvCond = condition ()
          val mopRef = ref None in
          conRef := Recv (queue [(recvCond, mopRef)]);
          release lock; wait recvCond;
          valOf (!mopRef) end |
        Recv q => let
          val recvCond = condition () 
          val mopRef = ref None in
          enqueue (q, (recvCond, mopRef));
          release lock; wait recvCond;
          valOf (!mopRef) end |
        Send (sendCond, m) =>
          conRef := Inac;
          release lock;
          signal sendCond;
          m end) 

    end 
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  structure FanInChan : CHAN = struct

  datatype 'a chan_content =
    Send of (condition * 'a) queue |
    Recv of condition * 'a option ref |
    Inac

  datatype 'a chan =
    Chn of 'a chan_content ref * mutex_lock

  fun channel () = Chn (ref Inac, mutexLock ())

  fun send (Chn (conRef, lock)) m = 
    acquire lock;
    case !conRef of
    Recv (recvCond, mopRef) => 
      mopRef := Some m; conRef := Inac;
      release lock; signal recvCond;
      () |
    Send q => let
      val sendCond = condition () in
      enqueue (q, (sendCond, m));
      release lock; wait sendCond;
      () end |
    Inac => let
      val sendCond = condition () in
      conRef := Send (queue [(sendCond, m)])
      release lock; wait sendCond; () end 

  fun recv (Chn (conRef, lock)) = let
    val recvCond = condition () 
    val mopRef = ref None in
    case cas (conRef, Inac, Recv (recvCond, mopRef)) of
      Inac => (* conRef already set *)
        wait recvCond; valOf (!mopRef) |
      Send q =>
        (* the current thread is the only one
        -* that updates the state from this state *)
        acquire lock;
        (let
          val (sendCond, m) = dequeue q in
          if (isEmpty q) then conRef := Inac else (); 
          release lock; signal sendCond; m end) |
      Recv _ => raise NeverHappens end end

  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]

structure OneToOneChan : CHAN = struct

  datatype 'a chan_content =
    Send of condition * 'a |
    Recv of condition * 'a option ref |
    Inac  

  datatype 'a chan = Chn of 'a chan_content ref

  fun channel () = Chn (ref Inac)

  fun send (Chn conRef) m = let
    val sendCond = condition () in
    case cas (conRef, Inac, Send (sendCond, m)) of
      Inac => 
        (* conRef already set to Send *)
        wait sendCond; () |
      Recv (recvCond, mopRef) =>
        (* the current thread is the only one
        -* that accesses conRef for this state *)
        mopRef := Some m; conRef := Inac;
        signal recvCond; () |
      Send _ => raise NeverHappens end end


  fun recv (Chn conRef) = let
    val recvCond = condition ();
    val mopRef = ref None in
    case cas (conRef, Inac, Recv (recvCond, mopRef)) of
      Inac => (* conRef already set to Recv*)
        wait recvCond; valOf (!mopRef) |
      Send (sendCond, m) =>
        (* the current thread is the only one
        -* that accesses conRef for this state *)
        conRef := Inac; signal sendCond; m |
      Recv _ => raise NeverHappens end end 

  end
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
  structure OneShotChan : CHAN = struct

  datatype 'a chan_content =
    Send of condition * 'a |
    Recv of condition * 'a option ref |
    Inac  

  datatype 'a chan = Chn of 'a chan_content ref * mutex_lock

  fun channel () = Chn (ref Inac, lock ())

  fun send (Chn (conRef, lock)) m = let
    val sendCond = condition () in
    case (conRef, Inac, Send (sendCond, m)) of
      Inac =>
        (* conRef already set to Send*)
        wait sendCond; () |
      Recv (recvCond, mopRef) =>
        mopRef := Some m; signal recvCond;
        () |
      Send _ => raise NeverHappens end end


  fun recv (Chn (conRef, lock)) = let
    val recvCond = condition ()
    val mopRef = ref None in
    case (conRef, Inac, Recv (recvCond, mopRef)) of
      Inac =>
        (* conRef already set to Recv*)
        wait recvCond; valOf (!mopRef) |
      Send (sendCond, m) =>
        acquire lock; signal sendCond;
        (* never relases lock;
        -* blocks others forever *)
        m |
      Recv _ =>
        acquire lock;
        (* never able to acquire lock;
        -* blocked forever *)
        raise NeverHappens end end

  end
  \end{lstlisting}

\begin{lstlisting}[language=ML, style=codestyle1]
structure OneShotToOneChan : CHAN = struct

  datatype 'a chan =
    Chn of condition * condition * 'a option ref

  fun channel () =
    Chn (condition (), condition (), ref None)

  fun send (Chn (sendCond, recvCond, mopRef)) m =
    mopRef := Some m; signal recvCond;  
    wait sendCond; ()

  fun recv (Chn (sendCond, recvCond, mopRef)) =
    wait recvCond; signal sendCond;
    valOf (!mopRef)

  end
  \end{lstlisting}


\section{Syntax}

\begin{lstlisting}[style=codestyle1]

  datatype var = Var string

  datatype exp = 
    Let var boundexp exp |
    Rslt var

  boundexp =
    Unt |
    MkChn |
    Prim prim |
    Spwn exp |
    Sync var |
    Fst var |
    Snd var |
    Case var var exp var exp |
    App var var and

  prim = 
    SendEvt var var |
    RecvEvt var |
    Pair var var |
    Lft var |
    Rht var |
    Abs var var ex

\end{lstlisting}



\section{Dynamic Semantics}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  datatype ctrl_label = 
    LNxt var | LSpwn var | LCall var | LRtn var

  type_synonym ctrl_path = (ctrl_label list)

  datatype chan = Chn ctrl_path var

  datatype val = 
    VUnt | VChn chan | VClsr prim (var %$\rightharpoonup$% val)

  datatype ctn = Ctn var exp (var %$\rightharpoonup$% val)  

  datatype state = Stt exp (var %$\rightharpoonup$% val) (ctn list) 

  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive
    seq_step ::
      bind * (var %$\rightharpoonup$% val)) %$\Rightarrow$% val %$\Rightarrow$% bool where
    LetUnt : 
      seq_step (Unt, env) VUnt |
    LetPrim :
      seq_step (Prim p, env) (VClsr p env) |
    LetFst :
      env xp = Some (VClsr (Pair x1 x2) envp) %$\Longrightarrow$%
      envp x1 = Some v %$\Longrightarrow$% 
      seq_step (Fst xp, env) v |
    LetSnd : 
      env xp = Some (VClsr (Pair x1 x2) envp) %$\Longrightarrow$%  
      envp x2 = Some v %$\Longrightarrow$% 
      seq_step (Snd xp, env) v


  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]


  inductive
    seq_step_up ::
      bind * (var %$\rightharpoonup$% val)) %$\Rightarrow$%
      exp * val_env %$\Rightarrow$% bool where 
    LetCaseLft :
      env xs = Some (VClsr (Lft xl') envl) %$\Longrightarrow$%
      envl xl' = Some vl %$\Longrightarrow$%
      seq_step_up
        (Case xs xl el xr er, env)
        (el, env(xl %$\mapsto$% vl)) |
    LetCaseRht : 
      env xs = Some (VClsr (Rht xr') envr) %$\Longrightarrow$% 
      envr xr' = Some vr %$\Longrightarrow$%
      seq_step_up
        (Case xs xl el xr er, env)
        (er, env(xr %$\mapsto$% vr)) |
    LetApp :
      env f = Some (VClsr (Abs fp xp el) envl) %$\Longrightarrow$% 
      env xa = Some va  %$\Longrightarrow$% 
      seq_step_up
        (App f xa, env)
        (el, envl(
          fp %$\mapsto$% (VClsr (Abs fp xp el) envl),
          xp %$\mapsto$% va))

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]


  type_synonym cmmn_set = (ctrl_path * chan * ctrl_path) set

  type_synonym trace_pool = ctrl_path %$\rightharpoonup$% state

  inductive
    leaf ::
      trace_pool %$\Rightarrow$% ctrl_path %$\Rightarrow$% bool where
    intro :
      trpl pi %$\neq$% None %$\Longrightarrow$% 
      (%$\nexists$% pi' . trpl pi' %$\neq$% None %$\land$% strict_prefix pi pi') %$\Longrightarrow$%  
      leaf trpl pi

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive
    concur_step ::
      trace_pool * cmmn_set %$\Rightarrow$%
      trace_pool * cmmn_set %$\Rightarrow$%
      bool where 
    Seq_Sttep_Down :
      leaf trpl pi %$\Longrightarrow$%
      trpl pi = Some
        (Stt (Rslt x) env
          ((Ctn xk ek envk) # k)) %$\Longrightarrow$%
      env x = Some v %$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(pi @ [LRtn xk] %$\mapsto$%
          (Stt ek (envk(xk %$\mapsto$% v)) k)), ys) |
    Seq_Step :
      leaf trpl pi %$\Longrightarrow$%
      trpl pi = Some
        (Stt (Let x  b e) env k) %$\Longrightarrow$%
      seq_step (b, env) v%$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(pi @ [LNxt x] %$\mapsto$%
          (Stt e (env(x %$\mapsto$% v)) k), ys) |
    Seq_Step_Up : 
      leaf trpl pi %$\Longrightarrow$%
      trpl pi = Some
        (Stt (Let x b e) env k) %$\Longrightarrow$%
      seq_step_up (b, env) (e', env') %$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(pi @ [LCall x] %$\mapsto$%
          (Stt e' env'
            ((Ctn x e env) # k))), ys) |
    LetMkCh : 
      leaf trpl pi %$\Longrightarrow$%
      trpl pi = Some (Stt (Let x MkChn e) env k) %$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(pi @ [LNxt x] %$\mapsto$%
          (Stt e (env(x %$\mapsto$% (VChn (Chn pi x)))) k)), ys) |
    LetSpwn :
      leaf trpl pi %$\Longrightarrow$%
      trpl pi = Some
        (Stt (Let x (Spwn ec) e) env k) %$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(
          pi @ [LNxt x] %$\mapsto$%
              (St e (env(x %$\mapsto$% VUnt)) k), 
          pi @ [LSpwn x] %$\mapsto$%
              (St ec env []), ys) |
    LetSync :
      leaf trpl pis %$\Longrightarrow$%
      trpl pis = Some
        (Stt (Let xs (Sync xse) es) envs ks) %$\Longrightarrow$%
      envs xse = Some
        (VClsr (SendEvt xsc xm) envse) %$\Longrightarrow$%
      leaf trpl pir  %$\Longrightarrow$%
      trpl pir = Some
        (Stt (Let xr (Sync xre) er) envr kr) %$\Longrightarrow$%
      envr xre = Some
        (VClsr (RecvEvt xrc) envre) %$\Longrightarrow$%
      envse xsc = Some (VChn c) %$\Longrightarrow$%
      envre xrc = Some (VChn c) %$\Longrightarrow$%
      envse xm = Some vm %$\Longrightarrow$%
      concur_step
        (trpl, ys)
        (trpl(
          pis @ [LNxt xs] %$\mapsto$%
            (Stt es (envs(xs %$\mapsto$% VUnt)) ks), 
          pir @ [LNxt xr] %$\mapsto$%
            (Stt er (envr(xr %$\mapsto$% vm)) kr)), 
          ys %$\cup$% {(pis, c, pir)})

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive
    star ::
      ('a %$\Rightarrow$% 'a %$\Rightarrow$% bool) %$\Rightarrow$%
      'a %$\Rightarrow$% 'a %$\Rightarrow$% bool for r where
    refl : star r x x |
    step : r x y %$\Longrightarrow$% star r y z %$\Longrightarrow$% star r x z
  \end{lstlisting}



\section{Dynamic Communication}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive
    is_send_path ::
      trace_pool %$\Rightarrow$% chan %$\Rightarrow$%
      control_path %$\Rightarrow$% bool where
    intro :
      trpl piy = Some
        (Stt (Let xy (Sync xe) en) env k) %$\Longrightarrow$%
      env xe = Some
        (VClsr (SendEvt xsc xm) enve) %$\Longrightarrow$%
      enve xsc = Some (VChn c) %$\Longrightarrow$%
      is_send_path trpl c piy

  inductive
    is_recv_path ::
      trace_pool %$\Rightarrow$% chan %$\Rightarrow$%
      control_path %$\Rightarrow$% bool where
    intro :
      trpl piy = Some
        (Stt (Let xy (Sync xe) en) env k) %$\Longrightarrow$%
      env xe = Some
        (VClsr (RecvEvt xrc) enve) %$\Longrightarrow$%
      enve xrc = Some (VChn c) %$\Longrightarrow$%
      is_recv_path trpl c piy

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive
    every_two ::
      ('a %$\Rightarrow$% bool) %$\Rightarrow$%
      ('a %$\Rightarrow$% 'a %$\Rightarrow$% bool) %$\Rightarrow$% bool where
    intro : (%$\forall$% pi1 pi2 .
        p x1 %$\longrightarrow$%
        p x2 %$\longrightarrow$%
        r x1 x2) %$\Longrightarrow$%
      every_two p r

  inductive
    ordered ::
      'a list %$\Rightarrow$% 'a list %$\Rightarrow$% bool where
    left : prefix pi1 pi2 %$\Longrightarrow$% ordered pi1 pi2 |
    right : prefix pi2 pi1 %$\Longrightarrow$% ordered pi1 pi2

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive one_shot :: trace_pool %$\Rightarrow$% chan %$\Rightarrow$% bool where
    intro :
      every_two
        (is_send_path trpl c) op= %$\Longrightarrow$% 
      one_shot trpl c

  inductive fan_out :: trace_pool %$\Rightarrow$% chan %$\Rightarrow$% bool where
    intro :
      every_two
        (is_send_path trpl c) ordered %$\Longrightarrow$%
      fan_out trpl c

  inductive fan_in :: trace_pool %$\Rightarrow$% chan %$\Rightarrow$% bool where
    intro :
      every_two
        (is_recv_path trpl c) ordered %$\Longrightarrow$% 
      fan_in trpl c

  inductive one_to_one :: trace_pool %$\Rightarrow$% chan %$\Rightarrow$% bool where
    intro :
      fan_out trpl c %$\Longrightarrow$%
      fan_in trpl c %$\Longrightarrow$% 
      one_to_one trpl c

  \end{lstlisting}


\section{Static Semantics}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  datatype abstract_value =
    AChn var |
    AUnt |
    APrim prim

  type_synonym abstract_env = var %$\Rightarrow$% abstract_value set

  fun rslt_var :: exp %$\Rightarrow$% var where
    rslt_var (Rslt x) = x |
    rslt_var (Let _ _ e) = (rslt_var e)

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]


  inductive
    may_be_eval_exp ::
      abstract_env * abstract_env %$\Rightarrow$%
      exp %$\Rightarrow$% bool where
    Result :
      may_be_eval_exp (V, C) (RESULT x) |
    let_unt :
      {AUnt} %$\subseteq$% V x %$\Longrightarrow$%
      may_be_eval_exp (V, C) e %$\Longrightarrow$% 
      may_be_eval_exp (V, C) (Let x Unt e) |
    let_chan : 
      {AChn x} %$\subseteq$% V x  %$\Longrightarrow$%
      may_be_eval_exp (V, C) e %$\Longrightarrow$%
      may_be_eval_exp (V, C) (Let x (MkChn) e) |
    let_send_evt : 
      {APrim (SendEvt xc xm)} %$\subseteq$% V x %$\Longrightarrow$%
      may_be_eval_exp (V, C) e %$\Longrightarrow$% 
      may_be_eval_exp (V, C)
        (Let x (Prim (SendEvt xc xm)) e) |
    let_recv_evt :
      {APrim (RecvEvt xc)} %$\subseteq$% V x %$\Longrightarrow$%
      may_be_eval_exp (V, C) e %$\Longrightarrow$% 
      may_be_eval_exp (V, C)
        (Let x (Prim (RecvEvt xc)) e) |
    let_pair : 
      {APrim (Pair x1 x2)} %$\subseteq$% V x %$\Longrightarrow$%
      may_be_eval_exp (V, C) e %$\Longrightarrow$% 
      may_be_eval_exp (V, C) (Let x (Pair x1 x2) e) |
    let_left : 
      {APrim (Left xp)} %$\subseteq$% V x %$\Longrightarrow$%
      may_be_eval_exp (V, C) e %$\Longrightarrow$% 
      may_be_eval_exp (V, C) (Let x (Left xp) e) |
    let_right :
      {APrim (Right xp)} %$\subseteq$% V x %$\Longrightarrow$%
      may_be_eval_exp (V, C) e %$\Longrightarrow$% 
      may_be_eval_exp (V, C) (Let x (Right xp) e) |
    let_abs : 
      {APrim (Abs f' x' e')} %$\subseteq$% V f' %$\Longrightarrow$%
      may_be_eval_exp (V, C) e' %$\Longrightarrow$%
      {APrim (Abs f' x' e')} %$\subseteq$% V x %$\Longrightarrow$%
      may_be_eval_exp (V, C) e %$\Longrightarrow$% 
      may_be_eval_exp (V, C) (Let x (Abs f' x' e') e) |
    let_spawn :
      {AUnt} %$\subseteq$% V x %$\Longrightarrow$%
      may_be_eval_exp (V, C) ec %$\Longrightarrow$% 
      may_be_eval_exp (V, C) e %$\Longrightarrow$%  
      may_be_eval_exp (V, C) (Let x (Spwn ec) e) |
    let_sync  : 
      %$\forall$% xsc xm xc . 
        (APrim (SendEvt xsc xm)) %$\in$% V xe %$\longrightarrow$% 
        AChn xc %$\in$% V xsc %$\longrightarrow$%
        {AUnt} %$\subseteq$% V x %$\land$% V xm %$\subseteq$% C xc %$\Longrightarrow$%
      %$\forall$% xrc xc . 
        (APrim (RecvEvt xrc)) %$\in$% V xe %$\longrightarrow$%
        AChn xc %$\in$% V xrc %$\longrightarrow$%
        C xc %$\subseteq$% V x %$\Longrightarrow$%
      may_be_eval_exp (V, C) e %$\Longrightarrow$%  
      may_be_eval_exp (V, C) (Let x (Syync xe) e) |
    let_fst : 
      %$\forall$% x1 x2.
        (APrim (Pair x1 x2)) %$\in$% V xp %$\longrightarrow$%
        V x1 %$\subseteq$% V x %$\Longrightarrow$% 
      may_be_eval_exp (V, C) e %$\Longrightarrow$% 
      may_be_eval_exp (V, C) (Let x (Fst xp) e) |
    let_snd : 
    %$\forall$% x1 x2 .
      (APrim (Pair x1 x2) %$\in$% V xp %$\longrightarrow$%
      V x2 %$\subseteq$% V x %$\Longrightarrow$% 
    may_be_eval_exp (V, C) e %$\Longrightarrow$% 
    may_be_eval_exp (V, C) (Let x (Snd xp) e) |
  let_case :
    %$\forall$% xl' .
      (APrim (Left xl')) %$\in$% V xs %$\longrightarrow$%
        V xl' %$\subseteq$% V xl %$\land$% V (rslt_var el) %$\subseteq$% V x %$\land$%
        may_be_eval_exp (V, C) el %$\Longrightarrow$%
    %$\forall$% xr' .
      (APrim (Right xr')) %$\in$% V xs %$\longrightarrow$%
        V xr' %$\subseteq$% V xr %$\land$% V (rslt_var er) %$\subseteq$% V x %$\land$%
        may_be_eval_exp (V, C) er %$\Longrightarrow$%
        may_be_eval_exp (V, C) e %$\Longrightarrow$% 
      may_be_eval_exp (V, C) (Let x (Case xs xl el xr er) e) |
  let_app :
    %$\forall$% f' x' e' .
      (APrim (Abs f' x' e') %$\in$% V f %$\longrightarrow$%
      V xa %$\subseteq$% V x' %$\land$%
      V (rslt_var e') %$\subseteq$% V x %$\Longrightarrow$% 
    may_be_eval_exp (V, C) e %$\Longrightarrow$% 
    may_be_eval_exp (V, C) (Let x (App f xa) e)

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]


  fun abstract :: val %$\Rightarrow$% abstract_value where
    abstract VUnt = AUnt |
    abstract VChn (Chn pi x) = AChn x |
    abstract VClsr p env = APrim p

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive 
    may_be_eval_val ::
      abstract_env * abstract_env %$\Rightarrow$% val %$\Rightarrow$% bool and  
    may_be_eval_env ::
      abstract_env * abstract_env %$\Rightarrow$% val_env %$\Rightarrow$% bool where
    Unt :
      may_be_eval_val (V, C) VUnt |
    Chan :
      may_be_eval_val (V, C) VChn c |
    SendEvt :
      may_be_eval_env (V, C) env %$\Longrightarrow$%
      may_be_eval_val (V, C) (VClsr (SendEvt _ _) env) |
    RecvEvt :
      may_be_eval_env (V, C) env %$\Longrightarrow$%
      may_be_eval_val (V, C) (VClsr (RecvEvt _) env) |
    Left :
      may_be_eval_env (V, C) env %$\Longrightarrow$%
      may_be_eval_val (V, C) (VClsr (Left _) env) |
    Right :
      may_be_eval_env (V, C) env %$\Longrightarrow$%
      may_be_eval_val (V, C) (VClsr (Right _) env) |
    Abs :
      {(APrim (Abs f x e)} %$\subseteq$% V f %$\Longrightarrow$% 
      may_be_eval_exp (V, C) e %$\Longrightarrow$% 
      may_be_eval_env (V, C) env %$\Longrightarrow$%
      may_be_eval_val (V, C) (VClsr (Abs f x e) env) |
    Pair :
      may_be_eval_env (V, C) env %$\Longrightarrow$%
      may_be_eval_val (V, C) (VClsr (Pair _ _) env) |
    intro :  
      %$\forall$% x v .
        env x = Some v %$\longrightarrow$%
        {abstract v} %$\subseteq$% V x %$\land$% may_be_eval_val (V, C) v %$\Longrightarrow$%
      may_be_eval_env (V, C) env

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive may_be_eval_stack ::
    abstract_env * abstract_env %$\Rightarrow$%
    abstract_value set %$\Rightarrow$% cont list %$\Rightarrow$% bool where
    Empty :
      may_be_eval_stack (V, C) valset [] |
    Nonempty : 
      valset %$\subseteq$% V x %$\Longrightarrow$%
      may_be_eval_exp (V, C) e %$\Longrightarrow$%
      may_be_eval_env (V, C) env %$\Longrightarrow$%
      may_be_eval_stack (V, C) (V (rslt_var e)) k %$\Longrightarrow$%
      may_be_eval_stack (V, C) valset ((Ctn x e env) # k)


  inductive may_be_eval_state ::
    abstract_env * abstract_env %$\Rightarrow$%
    state %$\Rightarrow$% bool where
    intro :
      may_be_eval_exp (V, C) e %$\Longrightarrow$%
      may_be_eval_env (V, C) env %$\Longrightarrow$%
      may_be_eval_stack (V, C) (V (rslt_var e)) k %$\Longrightarrow$%
      may_be_eval_state (V, C) (Stt e env k)

  inductive may_be_eval_pool ::
    abstract_env * abstract_env %$\Rightarrow$%
    trace_pool %$\Rightarrow$% bool where
    intro :
      %$\forall$% pi st .
        trpl pi = Some st %$\longrightarrow$%
        may_be_eval_state (V, C) st %$\Longrightarrow$% 
      may_be_eval_pool (V, C) trpl

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  theorem may_be_eval_preserved_under_concur_step : "
    may_be_eval_pool (V, C) trpl %$\Longrightarrow$% 
    concur_step (trpl, ys) (trpl', ys') %$\Longrightarrow$%
    may_be_stati_eval_pool (V, C) trpl'"
  proof outline
  qed

  theorem may_be_eval_preserved_under_concur_step_star : "
    may_be_eval_pool (V, C) trpl %$\Longrightarrow$% 
    star concur_step (trpl, ys) (trpl', ys')  %$\Longrightarrow$% 
    may_be_concur_step (V, C) trpl'"
  proof outline
  qed
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  theorem trace_pool_snapshot_value_not_bound_sound : "
    env x = Some v %$\Longrightarrow$%
    trpl pi = Some (Stt e env k) %$\Longrightarrow$%
    may_be_eval_pool (V, C) trpl %$\Longrightarrow$%
    {abstract v} %$\subseteq$% V x "
  proof outline
  qed
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  theorem trace_pool_always_value_not_bound_sound : "
    env' x = Some v %$\Longrightarrow$%
    may_be_eval_pool (V, C) trpl %$\Longrightarrow$% 
    star concur_step (trpl, ys) (trpl', ys') %$\Longrightarrow$%
    trpl' pi = Some (Stt e' env' k') %$\Longrightarrow$%
    {abstract v} %$\subseteq$% V x"
  proof outline
  qed

  theorem exp_always_value_not_bound_sound : "
    env' x = Some v %$\Longrightarrow$%
    may_be_eval_exp (V, C) e %$\Longrightarrow$%
    star concur_step
      ([[] %$\mapsto$% (Stt e (%$\lambda$% _ . None) [])], ys)
      (trpl', ys') %$\Longrightarrow$%
    trpl' pi = Some (Stt e' env' k') %$\Longrightarrow$%
    {abstract v} %$\subseteq$% V x"
  proof outline
  qed

  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive is_super_exp :: exp %$\Rightarrow$% exp %$\Rightarrow$% bool where
    Refl :
      is_super_exp e e | 
    let_Spawn_Child
      is_super_exp ec e %$\Longrightarrow$%
      is_super_exp (Let x (Spwn ec) en) e |
    let_Case_Left :
      is_super_exp el e %$\Longrightarrow$%
      is_super_exp (Let x (case xs xl el xr er) en) e |
    let_Case_Right :
      is_super_exp er e %$\Longrightarrow$%
      is_super_exp (Let x (case xs xl el xr er) en) e |
    let_Abs_Body : "
      is_super_exp eb e %$\Longrightarrow$%
      is_super_exp (Let x (Abs f xp eb) en) e | 
    Let :
      is_super_exp en e %$\Longrightarrow$%
      is_super_exp (Let x b en) e

  inductive
    is_super_exp_left :: exp %$\Rightarrow$% exp %$\Rightarrow$% bool where
    Refl :
      is_super_exp_left e0 e0 | 
    let_Spawn_Child :
      is_super_exp_left e0 (Let x (Spwn ec) en)%$\Longrightarrow$%
      is_super_exp_left e0 ec |
    let_Case_Left :
      is_super_exp_left e0 (Let x (case xs xl el xr er) en) %$\Longrightarrow$%
      is_super_exp_left e0 el |
    let_Case_Right :
      is_super_exp_left e0 (Let x (case xs xl el xr er) en) %$\Longrightarrow$%
      is_super_exp_left e0 er |
    let_Abs_Body :
      is_super_exp_left e0 (Let x (Abs f xp eb) en) %$\Longrightarrow$%
      is_super_exp_left e0 eb | 
    Let :
      is_super_exp_left e0 (Let x b en) %$\Longrightarrow$%
      is_super_exp_left e0 en

  inductive
    is_super_exp_over_prim :: exp %$\Rightarrow$% prim %$\Rightarrow$% bool where
    SendEvt :
      is_super_exp_over_prim e0 (SendEvt xC xM) |
    RecvEvt :
      is_super_exp_over_prim e0 (RecvEvt xC) |
    Pair :
      is_super_exp_over_prim e0 (Pair x1 x2) |
    Left :
      is_super_exp_over_prim e0 (Left x) |
    Right :
      is_super_exp_over_prim e0 (Right x) |
    Abs :
      is_super_exp_left e0 eb %$\Longrightarrow$%
      is_super_exp_over_prim e0 (Abs fp xp eb) 

  inductive 
    is_super_exp_over_env :: exp %$\Rightarrow$% env %$\Rightarrow$% bool and
    is_super_exp_over_val :: exp %$\Rightarrow$% val %$\Rightarrow$% bool where
    VUnt :
      is_super_exp_over_val e0 VUnt |
    VChn :
      is_super_exp_over_val e0 (VChn c) |
    VClsr : "
      is_super_exp_over_prim e0 p %$\Longrightarrow$%
      is_super_exp_over_env e0 env' %$\Longrightarrow$%
      is_super_exp_over_val e0 (VClsr p env') |
    intro : "
      %$\forall$% x v .
        env x = Some v %$\longrightarrow$%
        is_super_exp_over_val e0 v %$\Longrightarrow$%
      is_super_exp_over_env e0 env

  inductive
    is_super_exp_over_stack ::
      exp %$\Rightarrow$% cont list %$\Rightarrow$% bool where
    Empty :
      is_super_exp_over_stack e0 [] |
    Nonempty :
      is_super_exp_left e0 ek %$\Longrightarrow$%
      is_super_exp_over_env e0 envk %$\Longrightarrow$%
      is_super_exp_over_stack e0 k %$\Longrightarrow$%
      is_super_exp_over_stack e0 ((Ctn xk ek envk) # k)

  inductive
    is_super_exp_over_state ::
      exp %$\Rightarrow$% state %$\Rightarrow$% bool where
    intro :
      is_super_exp_left e0 e %$\Longrightarrow$%
      is_super_exp_over_env e0 env %$\Longrightarrow$%
      is_super_exp_over_stack e0 k %$\Longrightarrow$%
      is_super_exp_over_state e0 (Ctn e env k)

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  lemma is_super_exp_trans : "
    is_super_exp ez ey %$\Longrightarrow$%
    is_super_exp ey ex %$\Longrightarrow$%
    is_super_exp ez ex"
  proof outline 
  qed


  lemma is_super_exp_over_state_preserved : "
    concur_step (trpl, ys) (trpl', ys') %$\Longrightarrow$%
    %$\forall$% pi st.
      trpl pi = Some st %$\longrightarrow$%
      is_super_exp_over_state e0 st %$\Longrightarrow$%
    trpl' pi' = Some st' %$\Longrightarrow$%
    is_super_exp_over_state e0 st'"
  proof outline 
  qed
  \end{lstlisting}


\begin{lstlisting}[style=codestyle1, escapechar=\%]

  lemma state_always_exp_not_reachable_sound : "
    star concur_step (trpl0, ys0) (trpl', ys') %$\Longrightarrow$%
    trpl0 = [[] %$\mapsto$% (Stt e0 (%$\lambda$% _ . None) [])] %$\Longrightarrow$%
    trpl' pi' = Some st' %$\Longrightarrow$%
    is_super_exp_over_state e0 st' "
  proof outline
  qed

  lemma exp_always_exp_not_reachable_sound : "
    star concur_step
    ([[] %$\mapsto$% (Stt e0 (%$\lambda$% _ . None) [])], {})
      (trpl', H') %$\Longrightarrow$%
    trpl' pi' = Some (Stt e' env' k')) %$\Longrightarrow$%
    is_super_exp e0 e' " 
  proof outline
  qed

  \end{lstlisting}

\section{Static Communication}
\begin{lstlisting}[style=codestyle1, escapechar=\%]
  datatype node_label = NLet var | NRslt var

  fun top_node_label :: exp %$\Rightarrow$% node_label where
    top_node_label (Let x b e) = NLet x |
    top_node_label (Rslt y) = NRslt y

  type_synonym node_set = node_label set

  type_synonym node_map = node_label %$\Rightarrow$% var set

  inductive
    may_be_static_send_node_label ::
      abstract_env %$\Rightarrow$% exp %$\Rightarrow$%
      var %$\Rightarrow$% node_label %$\Rightarrow$% bool where
    intro:
      {AChn xC} %$\subseteq$% V xSC %$\Longrightarrow$%
      {APrim (SendEvt xSC xM)} %$\subseteq$% V xE %$\Longrightarrow$%
      is_super_exp e (Let x (Sync xE) e') %$\Longrightarrow$%
      may_be_static_send_node_label V e xC (NLet x)

  inductive
    may_be_static_recv_node_label ::
      abstract_env %$\Rightarrow$% exp %$\Rightarrow$%
      var %$\Rightarrow$% node_label %$\Rightarrow$% bool where
    intro:
      {AChn xC} %$\subseteq$% V xRC %$\Longrightarrow$%
      {APrim (RecvEvt xRC)} %$\subseteq$% V xE %$\Longrightarrow$%
      is_super_exp e (Let x (Sync xE) e') %$\Longrightarrow$%
      may_be_static_recv_node_label V e xC (NLet x)

  \end{lstlisting}

\section{Static Communication part A}
\begin{lstlisting}[style=codestyle1, escapechar=\%]

  datatype edge_label = ENext | ESpawn | ECall | EReturn

  type_synonym flow_label = node_label * edge_label * node_label

  type_synonym flow_set = flow_label set

  type_synonym step_label = node_label * edge_label

  type_synonym abstract_path = step_label list
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]


inductive simple_flow_set :: "abstract_env ⇒ (node_label * edge_label * node_label) set ⇒ exp ⇒ bool"  where
  Result: "
    simple_flow_set V F (RESULT x)
  " |
  Let_Unit: "
    ⟦
      {(NLet x , ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = ⦇⦈ in e)
  " |
  Let_Chan: "
    ⟦
      {(NLet x, ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = CHAN ⦇⦈ in e)
  " |
  Let_Send_Evt: "
    ⟦
      {(NLet x, ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = SEND EVT x⇩c x⇩m in e)
  " |
  Let_Recv_Evt: "
    ⟦
      {(NLet x, ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = RECV EVT x⇩c in e)
  " |
  Let_Pair: "
    ⟦
      {(NLet x, ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = ⦇x⇩1, x⇩2⦈ in e)
  " |
  Let_Left: "
    ⟦
      {(NLet x, ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = LEFT x⇩p in e)
  " |
  Let_Right: "
    ⟦
      {(NLet x, ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = RIGHT x⇩p in e)
  " |
  Let_Abs: "
    ⟦
      {(NLet x, ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e⇩b;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = FN f x⇩p . e⇩b  in e)
  " |
  Let_Spawn: "
    ⟦
      {
        (NLet x, ENext, top_node_label e),
        (NLet x, ESpawn, top_node_label e⇩c)
      } ⊆ F;
      simple_flow_set V F e⇩c;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = SPAWN e⇩c in e)
  " |
  Let_Sync: "
    ⟦
      {(NLet x, ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = SYNC xSE in e)
  " |
  Let_Fst: "
    ⟦
      {(NLet x, ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = FST x⇩p in e)
  " |
  Let_Snd: "
    ⟦
      {(NLet x, ENext, top_node_label e)} ⊆ F;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = SND x⇩p in e)
  " |
  Let_Case: "
    ⟦
      {
        (NLet x, ECall, top_node_label e⇩l),
        (NLet x, ECall, top_node_label e⇩r),
        (NResult (⌊e⇩l⌋), EReturn, top_node_label e),
        (NResult (⌊e⇩r⌋), EReturn, top_node_label e)
      } ⊆ F;
      simple_flow_set V F e⇩l;
      simple_flow_set V F e⇩r;
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = CASE x⇩s LEFT x⇩l |> e⇩l RIGHT x⇩r |> e⇩r in e)
  " |
  Let_App: "
    ⟦
      (∀ f' x⇩p e⇩b . ^Abs f' x⇩p e⇩b ∈ V f ⟶
        {
          (NLet x, ECall, top_node_label e⇩b),
          (NResult (⌊e⇩b⌋), EReturn, top_node_label e)
        } ⊆ F);
      simple_flow_set V F e
    ⟧ ⟹
    simple_flow_set V F (LET x = APP f x⇩a in e)
  "

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  
inductive may_be_path :: "abstract_env ⇒ flow_set ⇒ node_label ⇒ (node_label ⇒ bool) ⇒ abstract_path ⇒ bool" where
  Empty: "
    isEnd start ⟹
    may_be_path V F start isEnd []
  " |
  Edge: "
    isEnd end ⟹
    {(start, edge, end)} ⊆ F ⟹
    may_be_path V F start isEnd [(start, edge)]
  " |
  Step: "
    may_be_path V F middle isEnd ((middle, edge') # path) ⟹
    {(start, edge, middle)} ⊆ F ⟹
    may_be_path V F start isEnd ((start, edge) # (middle, edge') # path)
  "
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  inductive may_be_inclusive :: "abstract_path ⇒ abstract_path ⇒ bool" (infix "≍" 55) where
  Prefix1: "
    prefix π⇩1 π⇩2 ⟹
    π⇩1 ≍ π⇩2
  " |
  Prefix2: "
    prefix π⇩2 π⇩1 ⟹
    π⇩1 ≍ π⇩2
  " |
  Spawn1: "
    π @ (NLet x, ESpawn) # π⇩1 ≍ π @ (NLet x, ENext) # π⇩2
  " |
  Spawn2: "
    π @ (NLet x, ENext) # π⇩1 ≍ π @ (NLet x, ESpawn) # π⇩2
  "
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive singular :: "abstract_path ⇒ abstract_path ⇒ bool" where
  equal: "
    π⇩1 = π⇩2 ⟹ 
    singular π⇩1 π⇩2
  " |
  exclusive: "
    ¬ (π⇩1 ≍ π⇩2) ⟹ 
    singular π⇩1 π⇩2
  "

inductive noncompetitive :: "abstract_path ⇒ abstract_path ⇒ bool" where
  ordered: "
    ordered π⇩1 π⇩2 ⟹ 
    noncompetitive π⇩1 π⇩2
  " |
  exclusive: "
    ¬ (π⇩1 ≍ π⇩2) ⟹ 
    noncompetitive π⇩1 π⇩2
  "
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

inductive static_one_shot :: "abstract_env ⇒ exp ⇒ var ⇒ bool" where
  Sync: "
    every_two (may_be_path V F (top_node_label e) (may_be_static_send_node_label V e xC)) singular ⟹
    simple_flow_set V F e ⟹
    static_one_shot V e xC 
  "

inductive static_one_to_one :: "abstract_env ⇒ exp ⇒ var ⇒ bool" where
  Sync: "
    every_two (may_be_path V F (top_node_label e) (may_be_static_send_node_label V e xC)) noncompetitive ⟹
    every_two (may_be_path V F (top_node_label e) (may_be_static_recv_node_label V e xC)) noncompetitive ⟹
    simple_flow_set V F e ⟹
    static_one_to_one V e xC 
  "

inductive static_fan_out :: "abstract_env ⇒ exp ⇒ var ⇒ bool" where
  Sync: "
    every_two (may_be_path V F (top_node_label e) (may_be_static_send_node_label V e xC)) noncompetitive ⟹
    simple_flow_set V F e ⟹
    static_fan_out V e xC 
  "

inductive static_fan_in :: "abstract_env ⇒ exp ⇒ var ⇒ bool" where
  Sync: "
    every_two (may_be_path V F (top_node_label e) (may_be_static_recv_node_label V e xC)) noncompetitive ⟹
    simple_flow_set V F e ⟹
    static_fan_in V e xC 
  "

  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
  inductive paths_correspond :: "control_path ⇒ abstract_path ⇒ bool" where
  Empty: "
    paths_correspond [] []
  " |
  Next: "
    paths_correspond π path ⟹
    paths_correspond (π @ [LNext x]) (path @ [(NLet x, ENext)])
  " |
  Spawn: "
    paths_correspond π path ⟹
    paths_correspond (π @ [LSpawn x]) (path @ [(NLet x, ESpawn)])
  " |
  Call: "
    paths_correspond π path ⟹
    paths_correspond (π @ [LCall x]) (path @ [(NLet x, ECall)])
  "  |
  Return: "
    paths_correspond π path ⟹
    paths_correspond (π @ [LReturn x]) (path @ [(NResult x, EReturn)])
  " 
  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]

  lemma abstract_paths_of_same_run_inclusive: "
  ([[] ↦ ⟨e;Map.empty;[]⟩], {}) →* (ℰ', H') ⟹ 
  ℰ' π1 ≠ None ⟹ 
  ℰ' π2 ≠ None ⟹ 
  paths_congruent π1 path1 ⟹
  paths_congruent π2 path2 ⟹
  path1 ≍ path2
"

  lemma equality_abstract_to_concrete: "
  path1 = path2 ⟹
  paths_correspond π1 path1 ⟹
  paths_correspond π2 path2 ⟹
  π1 = π2
"

  lemma abstract_paths_equal_or_exclusive_implies_dynamic_paths_equal: "
pathSync = pathSynca ∨ (¬ pathSynca ≍ pathSync) ⟹ 

([[] ↦ ⟨e;Map.empty;[]⟩], {}) →* (ℰ', H') ⟹
ℰ' π⇩1 ≠ None ⟹ 
ℰ' π⇩2 ≠ None ⟹ 

paths_correspond π⇩1 pathSync ⟹
paths_correspond π⇩2 pathSynca ⟹

π⇩1 = π⇩2
"


  \end{lstlisting}

\begin{lstlisting}[style=codestyle1, escapechar=\%]
inductive 
  simple_flow_set_env :: "abstract_env ⇒ flow_set ⇒ env ⇒ bool"  and
  simple_flow_set_val :: "abstract_env ⇒ flow_set ⇒ val ⇒ bool"
where
  Intro: "
    ∀ x ω . ρ x = Some ω ⟶ {|ω|} ⊆ 𝒱 x ∧ simple_flow_set_val V F ω ⟹
    simple_flow_set_env V F ρ
  " |

  Unit: "
    simple_flow_set_val V F VUnit
  " |

  Chan: "
    simple_flow_set_val V F (VChan c)
  " |

  Send_Evt: "
    simple_flow_set_env V F ρ ⟹
    simple_flow_set_val V F (VClosure (Send_Evt _ _) ρ)
  " |

  Recv_Evt: "
    simple_flow_set_env V F ρ ⟹
    simple_flow_set_val V F (VClosure (Recv_Evt _) ρ)
  " |

  Left: "
    simple_flow_set_env V F ρ ⟹
    simple_flow_set_val V F (VClosure (Left _) ρ)
  " |

  Right: "
    simple_flow_set_env V F ρ ⟹
    simple_flow_set_val V F (VClosure (Right _) ρ)
  " |

  Abs: "
    simple_flow_set V F e ⟹ 
    simple_flow_set_env V F  ρ ⟹
    simple_flow_set_val V F (VClosure (Abs f x e) ρ)
  " |

  Pair: "
    simple_flow_set_env V F ρ ⟹
    simple_flow_set_val V F (VClosure (Pair _ _) ρ)
  " 

inductive simple_flow_set_stack :: "abstract_env ⇒ flow_set ⇒ cont list ⇒ bool" where
  Empty: "simple_flow_set_stack V F []" |
  Nonempty: "
    ⟦ 
      simple_flow_set V F e;
      simple_flow_set_env V F ρ;
      simple_flow_set_stack V F κ
    ⟧ ⟹ 
    simple_flow_set_stack V F (⟨x, e, ρ⟩ # κ)
  "


inductive simple_flow_set_pool :: "abstract_env ⇒ flow_set ⇒ trace_pool ⇒ bool"  where
  Intro: "
    (∀ π e ρ κ . E π = Some (⟨e;ρ;κ⟩) ⟶ 
      simple_flow_set V F e ∧
      simple_flow_set_env V F ρ ∧
      simple_flow_set_stack V F κ
      ) ⟹ 
    simple_flow_set_pool V F E
  "

  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]


  lemma simple_flow_set_pool_preserved_star: "
  simple_flow_set_pool V F ([[] ↦ ⟨e;Map.empty;[]⟩]) ⟹
  (V, C) ⊨⇩e e ⟹
  ℰ' π = Some (⟨LET x = b in e⇩n;ρ;κ⟩) ⟹
  ([[] ↦ ⟨e;Map.empty;[]⟩], {}) →* (ℰ', H') ⟹
  isEnd (NLet x) ⟹
  simple_flow_set_pool V F ℰ'
"
sorry

lemma simple_flow_set_pool_implies_may_be_path: "
  ℰ' π = Some (⟨LET x = b in e⇩n;ρ;κ⟩) ⟹
  ([[] ↦ ⟨e;Map.empty;[]⟩], {}) →* (ℰ', H') ⟹ 
  (V, C) ⊨⇩e e ⟹
  simple_flow_set_pool V F ℰ' ⟹
  isEnd (NLet x) ⟹
  ∃ path . 
    paths_correspond π path ∧
    may_be_path V F (top_node_label e) isEnd path
"
sorry

  \end{lstlisting}



\begin{lstlisting}[style=codestyle1, escapechar=\%]

  lemma path_not_traceable_sound: "
  ℰ' π = Some (⟨LET x = b in e⇩n;ρ;κ⟩) ⟹
  ([[] ↦ ⟨e;Map.empty;[]⟩], {}) →* (ℰ', H') ⟹ 
  (V, C) ⊨⇩e e ⟹
  simple_flow_set V F e ⟹
  isEnd (NLet x) ⟹
  ∃ path . 
    paths_correspond π path ∧
    may_be_path V F (top_node_label e) isEnd path
"
by (metis lift_simple_flow_set_to_pool simple_flow_set_pool_implies_may_be_path simple_flow_set_pool_preserved_star)

  \end{lstlisting}



\begin{lstlisting}[style=codestyle1, escapechar=\%]
theorem one_shot_sound: "
  ⟦
    static_one_shot V e xC;
    (V, C) ⊨⇩e e;
    ([[] ↦ ⟨e;Map.empty;[]⟩], {}) →* (ℰ', H')
  ⟧ ⟹
  one_shot ℰ' (Ch π xC)
"


  theorem fan_out_sound: "
  ⟦
    static_fan_out V e xC;
    (V, C) ⊨⇩e e;
    ([[] ↦ ⟨e;Map.empty;[]⟩], {}) →* (ℰ', H')
  ⟧ ⟹
  fan_out ℰ' (Ch π xC)
"
  theorem fan_in_sound: "
  ⟦
    static_fan_in V e xC;
    (V, C) ⊨⇩e e;
    ([[] ↦ ⟨e;Map.empty;[]⟩], {}) →* (ℰ', H')
  ⟧ ⟹
  fan_in ℰ' (Ch π xC)
"

  theorem one_to_one_sound: "
  ⟦
    static_one_to_one V e xC;
    (V, C) ⊨⇩e e;
    ([[] ↦ ⟨e;Map.empty;[]⟩], {}) →* (ℰ', H')
  ⟧ ⟹
  one_to_one ℰ' (Ch π xC)
"


  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]
  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]
  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]
  \end{lstlisting}
\begin{lstlisting}[style=codestyle1, escapechar=\%]
  \end{lstlisting}

\end{document}
\end{document}
{Document}
