<pre><span class="syntax0"><span class="gutter">   1 </span><span class="syntax-KEYWORD1">theory</span> Analysis
<span class="gutter">   2 </span>  <span class="syntax-KEYWORD2">imports</span> Main Syntax
<span class="gutter">   3 </span><span class="syntax-KEYWORD2">begin</span>
<span class="gutter">   4 </span>
<span class="gutterH">   5 </span><span class="syntax-KEYWORD1">datatype</span> abstract_value <span class="syntax-OPERATOR">=</span> Chan var <span class="syntax-OPERATOR">|</span> Unit <span class="syntax-OPERATOR">|</span> Prim prim
<span class="gutter">   6 </span>
<span class="gutter">   7 </span><span class="syntax-KEYWORD1">type_synonym</span> abstract_value_env <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;var &rArr; abstract_value set&quot;</span>
<span class="gutter">   8 </span>
<span class="gutter">   9 </span><span class="syntax-KEYWORD1">fun</span> result_var <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;exp &rArr; var&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutterH">  10 </span>  <span class="syntax-LITERAL1">&quot;result_var (RESULT x) = x&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  11 </span>  <span class="syntax-LITERAL1">&quot;result_var (LET _ = _ in e) = result_var e&quot;</span>
<span class="gutter">  12 </span>
<span class="gutter">  13 </span><span class="syntax-KEYWORD1">inductive</span> val_env_accept <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;abstract_value_env &rArr; exp &rArr; bool&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&#8872;&quot;</span> 55<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter">  14 </span>  Result<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH">  15 </span><span class="syntax-LITERAL1">    &rho; &#8872; (RESULT x)</span>
<span class="gutter">  16 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  17 </span>  Let_Unit<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  18 </span><span class="syntax-LITERAL1">    &#10214; {Unit} &sube; (&rho; x); &rho; &#8872; e &#10215; &#10233; </span>
<span class="gutter">  19 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = &#10631;&#10632; in e)</span>
<span class="gutterH">  20 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  21 </span>  Let_Abs <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  22 </span><span class="syntax-LITERAL1">    &#10214; </span>
<span class="gutter">  23 </span><span class="syntax-LITERAL1">      {Prim (P_Abs f' x' e')} &sube; (&rho; f');</span>
<span class="gutter">  24 </span><span class="syntax-LITERAL1">      &rho; &#8872; e';</span>
<span class="gutterH">  25 </span><span class="syntax-LITERAL1">      {Prim (P_Abs f' x' e')} &sube; (&rho; x);</span>
<span class="gutter">  26 </span><span class="syntax-LITERAL1">      &rho; &#8872; e </span>
<span class="gutter">  27 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutter">  28 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = B_Prim (P_Abs f' x' e') in e)</span>
<span class="gutter">  29 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutterH">  30 </span>  Let_Pair <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  31 </span><span class="syntax-LITERAL1">    &#10214; </span>
<span class="gutter">  32 </span><span class="syntax-LITERAL1">      {Prim (P_Pair x1 x2)} &sube; (&rho; x);</span>
<span class="gutter">  33 </span><span class="syntax-LITERAL1">      &rho; &#8872; e </span>
<span class="gutter">  34 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutterH">  35 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = B_Prim (P_Pair x1 x2) in e)</span>
<span class="gutter">  36 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  37 </span>  Let_Left <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  38 </span><span class="syntax-LITERAL1">    &#10214; </span>
<span class="gutter">  39 </span><span class="syntax-LITERAL1">      {Prim (P_Left x_p)} &sube; (&rho; x);</span>
<span class="gutterH">  40 </span><span class="syntax-LITERAL1">      &rho; &#8872; e </span>
<span class="gutter">  41 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutter">  42 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = B_Prim (P_Left x_p) in e)</span>
<span class="gutter">  43 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  44 </span>  Let_Right <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH">  45 </span><span class="syntax-LITERAL1">    &#10214; </span>
<span class="gutter">  46 </span><span class="syntax-LITERAL1">      {Prim (P_Right x_p)} &sube; (&rho; x);</span>
<span class="gutter">  47 </span><span class="syntax-LITERAL1">      &rho; &#8872; e </span>
<span class="gutter">  48 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutter">  49 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = B_Prim (P_Right x_p) in e)</span>
<span class="gutterH">  50 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  51 </span>  Let_Send_Evt <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  52 </span><span class="syntax-LITERAL1">    &#10214; </span>
<span class="gutter">  53 </span><span class="syntax-LITERAL1">      {Prim (P_Send_Evt x_ch x_m)} &sube; (&rho; x);</span>
<span class="gutter">  54 </span><span class="syntax-LITERAL1">      &rho; &#8872; e </span>
<span class="gutterH">  55 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutter">  56 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = B_Prim (P_Send_Evt x_ch x_m) in e)</span>
<span class="gutter">  57 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  58 </span>  Let_Recv_Evt <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  59 </span><span class="syntax-LITERAL1">    &#10214; </span>
<span class="gutterH">  60 </span><span class="syntax-LITERAL1">      {Prim (P_Recv_Evt x_ch)} &sube; (&rho; x);</span>
<span class="gutter">  61 </span><span class="syntax-LITERAL1">      &rho; &#8872; e </span>
<span class="gutter">  62 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutter">  63 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = B_Prim (P_Recv_Evt x_ch) in e)</span>
<span class="gutter">  64 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutterH">  65 </span>  Let_Case<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  66 </span><span class="syntax-LITERAL1">    &#10214;</span>
<span class="gutter">  67 </span><span class="syntax-LITERAL1">      &#8896; x_l' . (Prim (P_Left x_l')) &isin; &rho; x_sum &#10233; </span>
<span class="gutter">  68 </span><span class="syntax-LITERAL1">        (&rho; x_l' &sube; &rho; x_l) &and; (&rho; (result_var e_l) &sube; &rho; x) &and; &rho; &#8872; e_l;</span>
<span class="gutter">  69 </span><span class="syntax-LITERAL1">      &#8896; x_r' :: var . Prim (P_Right x_r') &isin; &rho; x_sum &#10233;</span>
<span class="gutterH">  70 </span><span class="syntax-LITERAL1">        &rho; x_r' &sube; &rho; x_r &and; &rho; (result_var e_r) &sube; &rho; x &and; &rho; &#8872; e_r</span>
<span class="gutter">  71 </span><span class="syntax-LITERAL1">    &#10215;&#10233; </span>
<span class="gutter">  72 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = CASE x_sum LEFT x_l |&gt; e_l RIGHT x_r |&gt; e_r in e)</span>
<span class="gutter">  73 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  74 </span>  Let_Fst<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH">  75 </span><span class="syntax-LITERAL1">    &#10214; </span>
<span class="gutter">  76 </span><span class="syntax-LITERAL1">      &#8896; x1 x2. Prim (P_Pair x1 x2) &isin; (&rho; x_p) &#10233; &rho; x1 &sube; &rho; x; </span>
<span class="gutter">  77 </span><span class="syntax-LITERAL1">      &rho; &#8872; e </span>
<span class="gutter">  78 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutter">  79 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = FST x_p in e)</span>
<span class="gutterH">  80 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  81 </span>  Let_Snd<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  82 </span><span class="syntax-LITERAL1">    &#10214; </span>
<span class="gutter">  83 </span><span class="syntax-LITERAL1">      &#8896; x1 x2 . Prim (P_Pair x1 x2) &isin; (&rho; x_p) &#10233; &rho; x2 &sube; &rho; x; </span>
<span class="gutter">  84 </span><span class="syntax-LITERAL1">      &rho; &#8872; e</span>
<span class="gutterH">  85 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutter">  86 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = SND x_p in e)</span>
<span class="gutter">  87 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  88 </span>  Let_App<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  89 </span><span class="syntax-LITERAL1">    &#10214;</span>
<span class="gutterH">  90 </span><span class="syntax-LITERAL1">      &#8896; x' e' . Prim (P_Abs _ x' e') &isin; &rho; x_f &#10233;</span>
<span class="gutter">  91 </span><span class="syntax-LITERAL1">        &rho; x_a &sube; &rho; x' &and;</span>
<span class="gutter">  92 </span><span class="syntax-LITERAL1">        &rho; (result_var e') &sube; &rho; x</span>
<span class="gutter">  93 </span><span class="syntax-LITERAL1">      ;</span>
<span class="gutter">  94 </span><span class="syntax-LITERAL1">      &rho; &#8872; e</span>
<span class="gutterH">  95 </span><span class="syntax-LITERAL1">    &#10215;&#10233; </span>
<span class="gutter">  96 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = APP x_f x_a in e)</span>
<span class="gutter">  97 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter">  98 </span>  Let_Sync  <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter">  99 </span><span class="syntax-LITERAL1">    &#10214;</span>
<span class="gutterH"> 100 </span><span class="syntax-LITERAL1">      &#8896; x_ch x_m . Prim (P_Send_Evt x_ch x_m) &isin; &rho; x_evt &#10233; </span>
<span class="gutter"> 101 </span><span class="syntax-LITERAL1">        {Unit} &sube; &rho; x;</span>
<span class="gutter"> 102 </span><span class="syntax-LITERAL1">      &#8896; x_ch . Prim (P_Recv_Evt x_ch) &isin; &rho; x_evt &#10233;</span>
<span class="gutter"> 103 </span><span class="syntax-LITERAL1">        (&#8899; x'. {v . &exist; x_m . v &isin; &rho; x_m &and; Prim (P_Send_Evt x_ch x_m) &isin; &rho; x'}) &sube; &rho; x;</span>
<span class="gutter"> 104 </span><span class="syntax-LITERAL1">      &rho; &#8872; e</span>
<span class="gutterH"> 105 </span><span class="syntax-LITERAL1">    &#10215;&#10233;  </span>
<span class="gutter"> 106 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = SYNC x_evt in e)</span>
<span class="gutter"> 107 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 108 </span>  Let_Chan<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 109 </span><span class="syntax-LITERAL1">    &#10214;</span>
<span class="gutterH"> 110 </span><span class="syntax-LITERAL1">      {Chan x} &sube; &rho; x;</span>
<span class="gutter"> 111 </span><span class="syntax-LITERAL1">      &rho; &#8872; e</span>
<span class="gutter"> 112 </span><span class="syntax-LITERAL1">    &#10215;&#10233;  </span>
<span class="gutter"> 113 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = CHAN &#10631;&#10632; in e)</span>
<span class="gutter"> 114 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutterH"> 115 </span>  Let_Spawn_Parent<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot; </span>
<span class="gutter"> 116 </span><span class="syntax-LITERAL1">    &#10214;</span>
<span class="gutter"> 117 </span><span class="syntax-LITERAL1">      {Unit} &sube; &rho; x;</span>
<span class="gutter"> 118 </span><span class="syntax-LITERAL1">      &rho; &#8872; e_child;</span>
<span class="gutter"> 119 </span><span class="syntax-LITERAL1">      &rho; &#8872; e</span>
<span class="gutterH"> 120 </span><span class="syntax-LITERAL1">    &#10215;&#10233;  </span>
<span class="gutter"> 121 </span><span class="syntax-LITERAL1">    &rho; &#8872; (LET x = SPAWN e_child in e)</span>
<span class="gutter"> 122 </span><span class="syntax-LITERAL1">  &quot;</span>
<span class="gutter"> 123 </span>
<span class="gutter"> 124 </span>
<span class="gutterH"> 125 </span><span class="syntax-KEYWORD1">type_synonym</span> abstract_path <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;(var + unit) list&quot;</span>
<span class="gutter"> 126 </span>
<span class="gutter"> 127 </span><span class="syntax-KEYWORD1">inductive</span> path_sub_accept <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;abstract_value_env &rArr; abstract_path &rArr; exp &rArr; bool&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 128 </span>  Result<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;path_sub_accept &rho; [Inl x] (RESULT x)&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 129 </span>  Let_Unit<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH"> 130 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; &pi; e &#10233; </span>
<span class="gutter"> 131 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; ((Inl x) # &pi;) (LET x = &#10631;&#10632; in e)</span>
<span class="gutter"> 132 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 133 </span>  Let_Prim<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 134 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; &pi; e &#10233; </span>
<span class="gutterH"> 135 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; ((Inl x) # &pi;) (LET x = B_Prim p in e)</span>
<span class="gutter"> 136 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 137 </span>  Let_Case_Left<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 138 </span><span class="syntax-LITERAL1">    &#10214;</span>
<span class="gutter"> 139 </span><span class="syntax-LITERAL1">      path_sub_accept &rho; &pi;_l e_l; </span>
<span class="gutterH"> 140 </span><span class="syntax-LITERAL1">      path_sub_accept &rho; &pi; e </span>
<span class="gutter"> 141 </span><span class="syntax-LITERAL1">    &#10215;&#10233; </span>
<span class="gutter"> 142 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; (&pi;_l @ ((Inl x) # &pi;)) (LET x = CASE x_sum LEFT x_l |&gt; e_l RIGHT _ |&gt; _ in e)</span>
<span class="gutter"> 143 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 144 </span>  Let_Case_Right<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH"> 145 </span><span class="syntax-LITERAL1">    &#10214;</span>
<span class="gutter"> 146 </span><span class="syntax-LITERAL1">      path_sub_accept &rho; &pi;_r e_r;</span>
<span class="gutter"> 147 </span><span class="syntax-LITERAL1">      path_sub_accept &rho; &pi; e</span>
<span class="gutter"> 148 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutter"> 149 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; (&pi;_r @ ((Inl x) # &pi;)) (LET x = CASE x_sum LEFT _ |&gt; _ RIGHT x_r |&gt; e_r in e)</span>
<span class="gutterH"> 150 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 151 </span>  Let_Fst<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 152 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; &pi; e &#10233; </span>
<span class="gutter"> 153 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; ((Inl x) # &pi;) (LET x = FST _ in e)</span>
<span class="gutter"> 154 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutterH"> 155 </span>  Let_Snd<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 156 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; &pi; e &#10233; </span>
<span class="gutter"> 157 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; ((Inl x) # &pi;) (LET x = SND _ in e)</span>
<span class="gutter"> 158 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 159 </span>  Let_App<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH"> 160 </span><span class="syntax-LITERAL1">    &#10214;</span>
<span class="gutter"> 161 </span><span class="syntax-LITERAL1">      (Prim (P_Abs f' x' e' )) &isin; (&rho; x_f);</span>
<span class="gutter"> 162 </span><span class="syntax-LITERAL1">       path_sub_accept (&rho;(x' := (&rho; x') &cap; (&rho; x_a))) &pi;' e'</span>
<span class="gutter"> 163 </span><span class="syntax-LITERAL1">    &#10215;&#10233; </span>
<span class="gutter"> 164 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; (&pi;' @ ((Inl x) # &pi;)) (LET x = APP x_f x_a in e)</span>
<span class="gutterH"> 165 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 166 </span>  Let_Sync<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 167 </span><span class="syntax-LITERAL1">   path_sub_accept &rho; &pi; e &#10233;</span>
<span class="gutter"> 168 </span><span class="syntax-LITERAL1">   path_sub_accept &rho; (Inl x # &pi;) (LET x = SYNC x_evt in e)</span>
<span class="gutter"> 169 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutterH"> 170 </span>  Let_Chan<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 171 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; &pi; e &#10233;</span>
<span class="gutter"> 172 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; (Inl x # &pi;) (LET x = CHAN &#10631;&#10632; in e)</span>
<span class="gutter"> 173 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 174 </span>  Let_Spawn_Parent<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot; </span>
<span class="gutterH"> 175 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; &pi; e &#10233;</span>
<span class="gutter"> 176 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; (Inl x # &pi;) (LET x = SPAWN _ in e)</span>
<span class="gutter"> 177 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 178 </span>  Let_Spawn_Child<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot; </span>
<span class="gutter"> 179 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; &pi; e_child &#10233;</span>
<span class="gutterH"> 180 </span><span class="syntax-LITERAL1">    path_sub_accept &rho; (Inr () # &pi;) (LET x = SPAWN e_child in _)</span>
<span class="gutter"> 181 </span><span class="syntax-LITERAL1">  &quot;</span> 
<span class="gutter"> 182 </span>
<span class="gutter"> 183 </span>
<span class="gutter"> 184 </span><span class="syntax-COMMENT1">(*  What's the way to show that the number of acceptable paths &le; 1 ?*)</span>
<span class="gutterH"> 185 </span>
<span class="gutter"> 186 </span><span class="syntax-KEYWORD1">definition</span> path_accept <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;abstract_path &rArr; exp &rArr; bool&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 187 </span>  <span class="syntax-LITERAL1">&quot;path_accept &pi; e &equiv; (&exist; &rho; . &rho; &#8872; e &and; path_sub_accept &rho; &pi; e)&quot;</span>
<span class="gutter"> 188 </span>
<span class="gutter"> 189 </span><span class="syntax-KEYWORD1">inductive</span> subexp <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;exp &rArr; exp &rArr; bool&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutterH"> 190 </span>  Refl<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;subexp e e&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 191 </span>  Step<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;subexp e' e &#10233; subexp e' (LET _ = _ in e)&quot;</span>
<span class="gutter"> 192 </span>
<span class="gutter"> 193 </span><span class="syntax-KEYWORD1">definition</span> send_sites <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;var &rArr; exp &rArr; var set&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 194 </span>  <span class="syntax-LITERAL1">&quot;send_sites c e = {x . &exist; y e' &rho; z. </span>
<span class="gutterH"> 195 </span><span class="syntax-LITERAL1">    subexp (LET x = SYNC y in e') e &and; </span>
<span class="gutter"> 196 </span><span class="syntax-LITERAL1">    val_env_accept &rho; e &and; </span>
<span class="gutter"> 197 </span><span class="syntax-LITERAL1">    Prim (P_Send_Evt c z) &isin; (&rho; y)</span>
<span class="gutter"> 198 </span><span class="syntax-LITERAL1">  }&quot;</span>
<span class="gutter"> 199 </span>
<span class="gutterH"> 200 </span><span class="syntax-KEYWORD1">definition</span> recv_sites <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;var &rArr; exp &rArr; var set&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 201 </span>  <span class="syntax-LITERAL1">&quot;recv_sites c e = {x . &exist; y e' &rho;. </span>
<span class="gutter"> 202 </span><span class="syntax-LITERAL1">    subexp (LET x = SYNC y in e') e &and; </span>
<span class="gutter"> 203 </span><span class="syntax-LITERAL1">    val_env_accept &rho; e &and; </span>
<span class="gutter"> 204 </span><span class="syntax-LITERAL1">    Prim (P_Recv_Evt c) &isin; (&rho; y)</span>
<span class="gutterH"> 205 </span><span class="syntax-LITERAL1">  }&quot;</span>
<span class="gutter"> 206 </span>
<span class="gutter"> 207 </span><span class="syntax-KEYWORD1">definition</span> paths <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;var set &rArr; var &rArr; exp &rArr; abstract_path set&quot;</span> <span class="syntax-KEYWORD2">where</span> 
<span class="gutter"> 208 </span>  <span class="syntax-LITERAL1">&quot;paths sites c e = {path @ [Inl x] | path x . </span>
<span class="gutter"> 209 </span><span class="syntax-LITERAL1">    (x &isin; sites) &and;  path_accept (path @ [Inl x]) e</span>
<span class="gutterH"> 210 </span><span class="syntax-LITERAL1">  }&quot;</span> 
<span class="gutter"> 211 </span>
<span class="gutter"> 212 </span><span class="syntax-KEYWORD1">definition</span> send_paths <span class="syntax-KEYWORD2">where</span> 
<span class="gutter"> 213 </span>  <span class="syntax-LITERAL1">&quot;send_paths c e = paths (send_sites c e) c e&quot;</span>
<span class="gutter"> 214 </span>
<span class="gutterH"> 215 </span><span class="syntax-KEYWORD1">definition</span> recv_paths <span class="syntax-KEYWORD2">where</span> 
<span class="gutter"> 216 </span>  <span class="syntax-LITERAL1">&quot;recv_paths c e = paths (recv_sites c e) c e&quot;</span>
<span class="gutter"> 217 </span>
<span class="gutter"> 218 </span>
<span class="gutter"> 219 </span><span class="syntax-KEYWORD1">inductive</span> one_path_max <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;abstract_path set &rArr; bool&quot;</span>  <span class="syntax-KEYWORD2">where</span>
<span class="gutterH"> 220 </span>  <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 221 </span><span class="syntax-LITERAL1">    &#10214;</span>
<span class="gutter"> 222 </span><span class="syntax-LITERAL1">      &#8896; path . path &isin; pset &#10233; no_path_loop path (* TO DO *)</span>
<span class="gutter"> 223 </span><span class="syntax-LITERAL1">    &#10215; &#10233;</span>
<span class="gutter"> 224 </span><span class="syntax-LITERAL1">    one_path_max pset</span>
<span class="gutterH"> 225 </span><span class="syntax-LITERAL1">  &quot;</span>
<span class="gutter"> 226 </span>
<span class="gutter"> 227 </span><span class="syntax-KEYWORD1">inductive</span> one_process_max <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;abstract_path set &rArr; bool&quot;</span>  <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 228 </span>  <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 229 </span><span class="syntax-LITERAL1">    &#10214;</span>
<span class="gutterH"> 230 </span><span class="syntax-LITERAL1">      &#8896; path . path &isin; pset &#10233; no_process_loop path (* TO DO *)</span>
<span class="gutter"> 231 </span><span class="syntax-LITERAL1">    &#10215; &#10233;</span>
<span class="gutter"> 232 </span><span class="syntax-LITERAL1">    one_process_max pset</span>
<span class="gutter"> 233 </span><span class="syntax-LITERAL1">  &quot;</span>
<span class="gutter"> 234 </span>
<span class="gutterH"> 235 </span><span class="syntax-COMMENT1">(*</span>
<span class="gutter"> 236 </span><span class="syntax-COMMENT1">value &quot;one_path_max (send_paths (Var ''x'') (RESULT (Var ''x'')))&quot;</span>
<span class="gutter"> 237 </span><span class="syntax-COMMENT1">*)</span>
<span class="gutter"> 238 </span>
<span class="gutter"> 239 </span><span class="syntax-KEYWORD1">datatype</span> topo_class <span class="syntax-OPERATOR">=</span> OneShot <span class="syntax-OPERATOR">|</span> OneToOne <span class="syntax-OPERATOR">|</span> FanOut <span class="syntax-OPERATOR">|</span> FanIn <span class="syntax-OPERATOR">|</span> Any
<span class="gutterH"> 240 </span>
<span class="gutter"> 241 </span><span class="syntax-KEYWORD1">type_synonym</span> topo_class_pair <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;var &times; topo_class&quot;</span>
<span class="gutter"> 242 </span>
<span class="gutter"> 243 </span><span class="syntax-KEYWORD1">inductive</span> class_pair_accept <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;topo_class_pair &rArr; exp &rArr; bool&quot;</span> <span class="syntax-KEYWORD2">where</span>
<span class="gutter"> 244 </span>  OneShot<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH"> 245 </span><span class="syntax-LITERAL1">    one_path_max (send_paths c e) &#10233; </span>
<span class="gutter"> 246 </span><span class="syntax-LITERAL1">    class_pair_accept (c, OneShot) e</span>
<span class="gutter"> 247 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span> 
<span class="gutter"> 248 </span>
<span class="gutter"> 249 </span>  OneToOne<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH"> 250 </span><span class="syntax-LITERAL1">    &#10214; </span>
<span class="gutter"> 251 </span><span class="syntax-LITERAL1">      one_process_max (send_paths c e) ;</span>
<span class="gutter"> 252 </span><span class="syntax-LITERAL1">      one_process_max (recv_paths c e) </span>
<span class="gutter"> 253 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutter"> 254 </span><span class="syntax-LITERAL1">    class_pair_accept (c, OneToOne) e</span>
<span class="gutterH"> 255 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span> 
<span class="gutter"> 256 </span>
<span class="gutter"> 257 </span>  FanOut<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutter"> 258 </span><span class="syntax-LITERAL1">    &#10214; </span>
<span class="gutter"> 259 </span><span class="syntax-LITERAL1">      one_process_max (send_paths c e)</span>
<span class="gutterH"> 260 </span><span class="syntax-LITERAL1">    &#10215; &#10233; </span>
<span class="gutter"> 261 </span><span class="syntax-LITERAL1">    class_pair_accept (c, FanOut) e</span>
<span class="gutter"> 262 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span> 
<span class="gutter"> 263 </span>
<span class="gutter"> 264 </span>  FanIn<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;</span>
<span class="gutterH"> 265 </span><span class="syntax-LITERAL1">    one_process_max (receive_paths c e) &#10233; </span>
<span class="gutter"> 266 </span><span class="syntax-LITERAL1">    class_pair_accept (c, OneToOne) e</span>
<span class="gutter"> 267 </span><span class="syntax-LITERAL1">  &quot;</span> <span class="syntax-OPERATOR">|</span> 
<span class="gutter"> 268 </span>
<span class="gutter"> 269 </span>  Any<span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;class_pair_accept (c, OneToOne) e&quot;</span>
<span class="gutterH"> 270 </span>
<span class="gutter"> 271 </span>
<span class="gutter"> 272 </span><span class="syntax-KEYWORD1">type_synonym</span> topo_class_env <span class="syntax-OPERATOR">=</span> <span class="syntax-LITERAL1">&quot;var &rArr; topo_class&quot;</span>
<span class="gutter"> 273 </span>
<span class="gutter"> 274 </span><span class="syntax-KEYWORD1">definition</span> class_env_accept <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;topo_class_env &rArr; exp &rArr; bool&quot;</span> <span class="syntax-KEYWORD2">where</span> 
<span class="gutterH"> 275 </span>  <span class="syntax-LITERAL1">&quot;class_env_accept E e &equiv; (&forall; (x::var) (t::topo_class) . ((E x) = t) &and; (class_pair_accept (x, t) e))&quot;</span>
<span class="gutter"> 276 </span>
<span class="gutter"> 277 </span>
<span class="gutter"> 278 </span>
<span class="gutter"> 279 </span><span class="syntax-KEYWORD1">inductive</span> precision_order <span class="syntax-OPERATOR">::</span> <span class="syntax-LITERAL1">&quot;topo_class &rArr; topo_class &rArr; bool&quot;</span> <span class="syntax-OPERATOR">(</span><span class="syntax-KEYWORD2">infix</span> <span class="syntax-LITERAL1">&quot;&#8828;&quot;</span> 55<span class="syntax-OPERATOR">)</span> <span class="syntax-KEYWORD2">where</span>  
<span class="gutterH"> 280 </span>  Edge1 <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;OneShot &#8828; OneToOne&quot;</span> <span class="syntax-OPERATOR">|</span> 
<span class="gutter"> 281 </span>  Edge2 <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;OneToOne &#8828; FanOut&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 282 </span>  Edge3 <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;OneToOne &#8828; FanIn&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 283 </span>  Edge4 <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;FanOut &#8828; Any&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 284 </span>  Edge5 <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;FanIn &#8828; Any&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutterH"> 285 </span>  Refl <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;t &#8828; t&quot;</span> <span class="syntax-OPERATOR">|</span>
<span class="gutter"> 286 </span>  Trans <span class="syntax-OPERATOR">:</span> <span class="syntax-LITERAL1">&quot;&#10214; a &#8828; b ; b &#8828; c &#10215; &#10233; a &#8828; c&quot;</span>
<span class="gutter"> 287 </span>
<span class="gutter"> 288 </span><span class="syntax-KEYWORD2">end</span>
</span></pre>
